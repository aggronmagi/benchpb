// Code generated by protoc-gen-gopb. DO NOT EDIT.
// Code generated by wpb. DO NOT EDIT.

package wproto

import (
	"encoding/base64"
	"errors"
	"math"
	"strconv"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/protobuf/encoding/protowire"
)

type enum_type int32

const (
	Zero enum_type = 0
	One  enum_type = 1
	Two  enum_type = 2
)

// Enum value maps for enum_type.
var (
	EnumType_name = map[int32]string{
		0: "zero",
		1: "one",
		2: "two",
	}
	EnumType_value = map[string]int32{
		"zero": 0,
		"one":  1,
		"two":  2,
	}
)

func (x enum_type) Enum() *enum_type {
	p := new(enum_type)
	*p = x
	return p
}

func (x enum_type) String() string {
	if name, ok := EnumType_name[int32(x)]; ok {
		return name
	}
	return strconv.FormatInt(int64(x), 10)
}

type FieldTestMessage struct {
	OptionalBool      bool                 `json:"optional_bool,omitempty"`
	OptionalEnum      int32                `json:"optional_enum,omitempty"`
	OptionalInt32     int32                `json:"optional_int32,omitempty"`
	OptionalSint32    int32                `json:"optional_sint32,omitempty"`
	OptionalUint32    uint32               `json:"optional_uint32,omitempty"`
	OptionalInt64     int64                `json:"optional_int64,omitempty"`
	OptionalSint64    int64                `json:"optional_sint64,omitempty"`
	OptionalUint64    uint64               `json:"optional_uint64,omitempty"`
	OptionalSfixed32  int32                `json:"optional_sfixed32,omitempty"`
	OptionalFixed32   uint32               `json:"optional_fixed32,omitempty"`
	OptionalFloat     float32              `json:"optional_float,omitempty"`
	OptionalSfixed64  int64                `json:"optional_sfixed64,omitempty"`
	OptionalFixed64   uint64               `json:"optional_fixed64,omitempty"`
	OptionalDouble    float64              `json:"optional_double,omitempty"`
	OptionalString    string               `json:"optional_string,omitempty"`
	OptionalBytes     []byte               `json:"optional_bytes,omitempty"`
	OptionalMessage   *Message1            `json:"optional_message,omitempty"`
	OptionalMessage2  *Message2            `json:"optional_message2,omitempty"`
	RepeatedBool      []bool               `json:"repeated_bool,omitempty"`
	RepeatedEnum      []int32              `json:"repeated_enum,omitempty"`
	RepeatedInt32     []int32              `json:"repeated_int32,omitempty"`
	RepeatedSint32    []int32              `json:"repeated_sint32,omitempty"`
	RepeatedUint32    []uint32             `json:"repeated_uint32,omitempty"`
	RepeatedInt64     []int64              `json:"repeated_int64,omitempty"`
	RepeatedSint64    []int64              `json:"repeated_sint64,omitempty"`
	RepeatedUint64    []uint64             `json:"repeated_uint64,omitempty"`
	RepeatedSfixed32  []int32              `json:"repeated_sfixed32,omitempty"`
	RepeatedFixed32   []uint32             `json:"repeated_fixed32,omitempty"`
	RepeatedFloat     []float32            `json:"repeated_float,omitempty"`
	RepeatedSfixed64  []int64              `json:"repeated_sfixed64,omitempty"`
	RepeatedFixed64   []uint64             `json:"repeated_fixed64,omitempty"`
	RepeatedDouble    []float64            `json:"repeated_double,omitempty"`
	RepeatedString    []string             `json:"repeated_string,omitempty"`
	RepeatedBytes     [][]byte             `json:"repeated_bytes,omitempty"`
	RepeatedMessage   []*Message1          `json:"repeated_message,omitempty"`
	RepeatedMessage2  []*Message2          `json:"repeated_message2,omitempty"`
	NopackBool        []bool               `json:"nopack_bool,omitempty"`
	NopackEnum        []int32              `json:"nopack_enum,omitempty"`
	NopackInt32       []int32              `json:"nopack_int32,omitempty"`
	NopackSint32      []int32              `json:"nopack_sint32,omitempty"`
	NopackUint32      []uint32             `json:"nopack_uint32,omitempty"`
	NopackInt64       []int64              `json:"nopack_int64,omitempty"`
	NopackSint64      []int64              `json:"nopack_sint64,omitempty"`
	NopackUint64      []uint64             `json:"nopack_uint64,omitempty"`
	NopackSfixed32    []int32              `json:"nopack_sfixed32,omitempty"`
	NopackFixed32     []uint32             `json:"nopack_fixed32,omitempty"`
	NopackFloat       []float32            `json:"nopack_float,omitempty"`
	NopackSfixed64    []int64              `json:"nopack_sfixed64,omitempty"`
	NopackFixed64     []uint64             `json:"nopack_fixed64,omitempty"`
	NopackDouble      []float64            `json:"nopack_double,omitempty"`
	NopackString      []string             `json:"nopack_string,omitempty"`
	NopackBytes       [][]byte             `json:"nopack_bytes,omitempty"`
	NopackMessage     []*Message1          `json:"nopack_message,omitempty"`
	NopackMessage2    []*Message2          `json:"nopack_message2,omitempty"`
	MapBool           map[int32]bool       `json:"map_bool,omitempty"`
	MapEnum           map[int32]int32      `json:"map_enum,omitempty"`
	MapInt32          map[int32]int32      `json:"map_int32,omitempty"`
	MapUint32         map[uint32]uint32    `json:"map_uint32,omitempty"`
	MapInt64          map[int64]int64      `json:"map_int64,omitempty"`
	MapUint64         map[uint64]uint64    `json:"map_uint64,omitempty"`
	MapFloat          map[int32]float32    `json:"map_float,omitempty"`
	MapDouble         map[int32]float64    `json:"map_double,omitempty"`
	MapString         map[int32]string     `json:"map_string,omitempty"`
	MapBytes          map[int32][]byte     `json:"map_bytes,omitempty"`
	MapMessage        map[int32]*Message1  `json:"map_message,omitempty"`
	MapMessage2       map[int32]*Message2  `json:"map_message2,omitempty"`
	MapKeyInt32       map[int32]int32      `json:"map_key_int32,omitempty"`
	MapKeyUint32      map[uint32]int32     `json:"map_key_uint32,omitempty"`
	MapKeyInt64       map[int64]int32      `json:"map_key_int64,omitempty"`
	MapKeyUint64      map[uint64]int32     `json:"map_key_uint64,omitempty"`
	MapKeyString      map[string]int32     `json:"map_key_string,omitempty"`
	MapInt32Int64     map[int32]int64      `json:"map_int32_int64,omitempty"`
	MapStringMessage  map[string]*Message1 `json:"map_string_message,omitempty"`
	MapStringMessage2 map[string]*Message2 `json:"map_string_message2,omitempty"`
}

func (x *FieldTestMessage) Reset() {
	*x = FieldTestMessage{}
}

// MarshalObject marshal data to []byte
func (x *FieldTestMessage) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *FieldTestMessage) MarshalSize() (size int) {
	if x.OptionalBool {
		// 1 = protowire.SizeTag(1)
		size += 1 + 1
	}
	if x.OptionalEnum != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.OptionalEnum))
	}
	if x.OptionalInt32 != 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeVarint(uint64(x.OptionalInt32))
	}
	if x.OptionalSint32 != 0 {
		// 1 = protowire.SizeTag(4)
		size += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.OptionalSint32)))
	}
	if x.OptionalUint32 != 0 {
		// 1 = protowire.SizeTag(5)
		size += 1 + protowire.SizeVarint(uint64(x.OptionalUint32))
	}
	if x.OptionalInt64 != 0 {
		// 1 = protowire.SizeTag(6)
		size += 1 + protowire.SizeVarint(uint64(x.OptionalInt64))
	}
	if x.OptionalSint64 != 0 {
		// 1 = protowire.SizeTag(7)
		size += 1 + protowire.SizeVarint(protowire.EncodeZigZag(int64(x.OptionalSint64)))
	}
	if x.OptionalUint64 != 0 {
		// 1 = protowire.SizeTag(8)
		size += 1 + protowire.SizeVarint(uint64(x.OptionalUint64))
	}
	if x.OptionalSfixed32 != 0 {
		// 1 = protowire.SizeTag(9)
		size += 1 + 4
	}
	if x.OptionalFixed32 != 0 {
		// 1 = protowire.SizeTag(10)
		size += 1 + 4
	}
	if x.OptionalFloat != 0 {
		// 1 = protowire.SizeTag(11)
		size += 1 + 4
	}
	if x.OptionalSfixed64 != 0 {
		// 1 = protowire.SizeTag(12)
		size += 1 + 8
	}
	if x.OptionalFixed64 != 0 {
		// 1 = protowire.SizeTag(13)
		size += 1 + 8
	}
	if x.OptionalDouble != 0 {
		// 1 = protowire.SizeTag(14)
		size += 1 + 8
	}
	if len(x.OptionalString) > 0 {
		// 1 = protowire.SizeTag(15)
		size += 1 + protowire.SizeBytes(len(x.OptionalString))
	}
	if len(x.OptionalBytes) > 0 {
		// 2 = protowire.SizeTag(16)
		size += 2 + protowire.SizeBytes(len(x.OptionalBytes))
	}
	if x.OptionalMessage != nil {
		// 2 = protowire.SizeTag(17)
		size += 2 + protowire.SizeBytes(x.OptionalMessage.MarshalSize())
	}
	if x.OptionalMessage2 != nil {
		// 2 = protowire.SizeTag(18)
		size += 2 + protowire.SizeBytes(x.OptionalMessage2.MarshalSize())
	}
	if len(x.RepeatedBool) > 0 {
		size += 2 // size += protowire.SizeTag(201)
		size += protowire.SizeBytes(len(x.RepeatedBool))
	}
	if len(x.RepeatedEnum) > 0 {
		size += 2 // size += protowire.SizeTag(202)
		if len(x.RepeatedEnum) > 0 {
			fsize := 0
			for _, item := range x.RepeatedEnum {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedInt32) > 0 {
		size += 2 // size += protowire.SizeTag(203)
		if len(x.RepeatedInt32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedInt32 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSint32) > 0 {
		size += 2 // size += protowire.SizeTag(204)
		if len(x.RepeatedSint32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedSint32 {
				fsize += protowire.SizeVarint(protowire.EncodeZigZag(int64(item)))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedUint32) > 0 {
		size += 2 // size += protowire.SizeTag(205)
		if len(x.RepeatedUint32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedUint32 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedInt64) > 0 {
		size += 2 // size += protowire.SizeTag(206)
		if len(x.RepeatedInt64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedInt64 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSint64) > 0 {
		size += 2 // size += protowire.SizeTag(207)
		if len(x.RepeatedSint64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedSint64 {
				fsize += protowire.SizeVarint(protowire.EncodeZigZag(int64(item)))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedUint64) > 0 {
		size += 2 // size += protowire.SizeTag(208)
		if len(x.RepeatedUint64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedUint64 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSfixed32) > 0 {
		size += 2 // size += protowire.SizeTag(209)
		size += protowire.SizeBytes(len(x.RepeatedSfixed32) * 4)
	}
	if len(x.RepeatedFixed32) > 0 {
		size += 2 // size += protowire.SizeTag(210)
		size += protowire.SizeBytes(len(x.RepeatedFixed32) * 4)
	}
	if len(x.RepeatedFloat) > 0 {
		size += 2 // size += protowire.SizeTag(211)
		size += protowire.SizeBytes(len(x.RepeatedFloat) * 4)
	}
	if len(x.RepeatedSfixed64) > 0 {
		size += 2 // size += protowire.SizeTag(212)
		size += protowire.SizeBytes(len(x.RepeatedSfixed64) * 8)
	}
	if len(x.RepeatedFixed64) > 0 {
		size += 2 // size += protowire.SizeTag(213)
		size += protowire.SizeBytes(len(x.RepeatedFixed64) * 8)
	}
	if len(x.RepeatedDouble) > 0 {
		size += 2 // size += protowire.SizeTag(214)
		size += protowire.SizeBytes(len(x.RepeatedDouble) * 8)
	}
	if len(x.RepeatedString) > 0 {
		// 2 = protowire.SizeTag(215)
		size += 2 * len(x.RepeatedString)
		for k := 0; k < len(x.RepeatedString); k++ {
			size += protowire.SizeBytes(len(x.RepeatedString[k]))
		}
	}
	if len(x.RepeatedBytes) > 0 {
		// 2 = protowire.SizeTag(216)
		size += 2 * len(x.RepeatedBytes)
		for k := 0; k < len(x.RepeatedBytes); k++ {
			size += protowire.SizeBytes(len(x.RepeatedBytes[k]))
		}
	}
	if x.RepeatedMessage != nil {
		// 2 = protowire.SizeTag(217)
		size += 2 * len(x.RepeatedMessage)
		for k := 0; k < len(x.RepeatedMessage); k++ {
			size += protowire.SizeBytes(x.RepeatedMessage[k].MarshalSize())
		}
	}
	if x.RepeatedMessage2 != nil {
		// 2 = protowire.SizeTag(218)
		size += 2 * len(x.RepeatedMessage2)
		for k := 0; k < len(x.RepeatedMessage2); k++ {
			size += protowire.SizeBytes(x.RepeatedMessage2[k].MarshalSize())
		}
	}
	if len(x.NopackBool) > 0 {
		// 2 = protowire.SizeTag(31)
		size += (2 + 1) * len(x.NopackBool)
	}
	if len(x.NopackEnum) > 0 {
		// 2 = protowire.SizeTag(32)
		size += 2 * len(x.NopackEnum)
		for k := 0; k < len(x.NopackEnum); k++ {
			size += protowire.SizeVarint(uint64(x.NopackEnum[k]))
		}
	}
	if len(x.NopackInt32) > 0 {
		// 2 = protowire.SizeTag(33)
		size += 2 * len(x.NopackInt32)
		for k := 0; k < len(x.NopackInt32); k++ {
			size += protowire.SizeVarint(uint64(x.NopackInt32[k]))
		}
	}
	if len(x.NopackSint32) > 0 {
		// 2 = protowire.SizeTag(34)
		size += 2 * len(x.NopackSint32)
		for k := 0; k < len(x.NopackSint32); k++ {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(x.NopackSint32[k])))
		}
	}
	if len(x.NopackUint32) > 0 {
		// 2 = protowire.SizeTag(35)
		size += 2 * len(x.NopackUint32)
		for k := 0; k < len(x.NopackUint32); k++ {
			size += protowire.SizeVarint(uint64(x.NopackUint32[k]))
		}
	}
	if len(x.NopackInt64) > 0 {
		// 2 = protowire.SizeTag(36)
		size += 2 * len(x.NopackInt64)
		for k := 0; k < len(x.NopackInt64); k++ {
			size += protowire.SizeVarint(uint64(x.NopackInt64[k]))
		}
	}
	if len(x.NopackSint64) > 0 {
		// 2 = protowire.SizeTag(37)
		size += 2 * len(x.NopackSint64)
		for k := 0; k < len(x.NopackSint64); k++ {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(x.NopackSint64[k])))
		}
	}
	if len(x.NopackUint64) > 0 {
		// 2 = protowire.SizeTag(38)
		size += 2 * len(x.NopackUint64)
		for k := 0; k < len(x.NopackUint64); k++ {
			size += protowire.SizeVarint(uint64(x.NopackUint64[k]))
		}
	}
	if len(x.NopackSfixed32) > 0 {
		// 2 = protowire.SizeTag(39)
		size += (2 + 4) * len(x.NopackSfixed32)
	}
	if len(x.NopackFixed32) > 0 {
		// 2 = protowire.SizeTag(40)
		size += (2 + 4) * len(x.NopackFixed32)
	}
	if len(x.NopackFloat) > 0 {
		// 2 = protowire.SizeTag(41)
		size += (2 + 4) * len(x.NopackFloat)
	}
	if len(x.NopackSfixed64) > 0 {
		// 2 = protowire.SizeTag(42)
		size += (2 + 8) * len(x.NopackSfixed64)
	}
	if len(x.NopackFixed64) > 0 {
		// 2 = protowire.SizeTag(43)
		size += (2 + 8) * len(x.NopackFixed64)
	}
	if len(x.NopackDouble) > 0 {
		// 2 = protowire.SizeTag(44)
		size += (2 + 8) * len(x.NopackDouble)
	}
	if len(x.NopackString) > 0 {
		// 2 = protowire.SizeTag(45)
		size += 2 * len(x.NopackString)
		for k := 0; k < len(x.NopackString); k++ {
			size += protowire.SizeBytes(len(x.NopackString[k]))
		}
	}
	if len(x.NopackBytes) > 0 {
		// 2 = protowire.SizeTag(46)
		size += 2 * len(x.NopackBytes)
		for k := 0; k < len(x.NopackBytes); k++ {
			size += protowire.SizeBytes(len(x.NopackBytes[k]))
		}
	}
	if x.NopackMessage != nil {
		// 2 = protowire.SizeTag(47)
		size += 2 * len(x.NopackMessage)
		for k := 0; k < len(x.NopackMessage); k++ {
			size += protowire.SizeBytes(x.NopackMessage[k].MarshalSize())
		}
	}
	if x.NopackMessage2 != nil {
		// 2 = protowire.SizeTag(48)
		size += 2 * len(x.NopackMessage2)
		for k := 0; k < len(x.NopackMessage2); k++ {
			size += protowire.SizeBytes(x.NopackMessage2[k].MarshalSize())
		}
	}
	if len(x.MapBool) > 0 {
		for mk, mv := range x.MapBool {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(51)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 1
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapEnum) > 0 {
		for mk, mv := range x.MapEnum {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(52)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt32) > 0 {
		for mk, mv := range x.MapInt32 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(53)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapUint32) > 0 {
		for mk, mv := range x.MapUint32 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(55)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt64) > 0 {
		for mk, mv := range x.MapInt64 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(56)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapUint64) > 0 {
		for mk, mv := range x.MapUint64 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(58)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapFloat) > 0 {
		for mk, mv := range x.MapFloat {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(61)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 4
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapDouble) > 0 {
		for mk, mv := range x.MapDouble {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(64)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 8
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapString) > 0 {
		for mk, mv := range x.MapString {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(65)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(len(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapBytes) > 0 {
		for mk, mv := range x.MapBytes {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(66)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(len(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapMessage) > 0 {
		for mk, mv := range x.MapMessage {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(67)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapMessage2) > 0 {
		for mk, mv := range x.MapMessage2 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(68)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyInt32) > 0 {
		for mk, mv := range x.MapKeyInt32 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(73)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyUint32) > 0 {
		for mk, mv := range x.MapKeyUint32 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(75)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyInt64) > 0 {
		for mk, mv := range x.MapKeyInt64 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(76)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyUint64) > 0 {
		for mk, mv := range x.MapKeyUint64 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(78)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyString) > 0 {
		for mk, mv := range x.MapKeyString {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(85)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt32Int64) > 0 {
		for mk, mv := range x.MapInt32Int64 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(90)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapStringMessage) > 0 {
		for mk, mv := range x.MapStringMessage {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(91)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapStringMessage2) > 0 {
		for mk, mv := range x.MapStringMessage2 {
			_ = mk
			_ = mv
			// 2 = protowire.SizeTag(92)
			size += 2
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *FieldTestMessage) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.OptionalBool {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, protowire.EncodeBool(x.OptionalBool))
	}
	if x.OptionalEnum != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.OptionalEnum))
	}
	if x.OptionalInt32 != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.OptionalInt32))
	}
	if x.OptionalSint32 != 0 {
		// data = protowire.AppendTag(data, 4, protowire.VarintType) => 00100000
		data = append(data, 0x20)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.OptionalSint32)))
	}
	if x.OptionalUint32 != 0 {
		// data = protowire.AppendTag(data, 5, protowire.VarintType) => 00101000
		data = append(data, 0x28)
		data = protowire.AppendVarint(data, uint64(x.OptionalUint32))
	}
	if x.OptionalInt64 != 0 {
		// data = protowire.AppendTag(data, 6, protowire.VarintType) => 00110000
		data = append(data, 0x30)
		data = protowire.AppendVarint(data, uint64(x.OptionalInt64))
	}
	if x.OptionalSint64 != 0 {
		// data = protowire.AppendTag(data, 7, protowire.VarintType) => 00111000
		data = append(data, 0x38)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.OptionalSint64)))
	}
	if x.OptionalUint64 != 0 {
		// data = protowire.AppendTag(data, 8, protowire.VarintType) => 01000000
		data = append(data, 0x40)
		data = protowire.AppendVarint(data, uint64(x.OptionalUint64))
	}
	if x.OptionalSfixed32 != 0 {
		// data = protowire.AppendTag(data, 9, protowire.Fixed32Type) => 01001101
		data = append(data, 0x4d)
		data = protowire.AppendFixed32(data, uint32(x.OptionalSfixed32))
	}
	if x.OptionalFixed32 != 0 {
		// data = protowire.AppendTag(data, 10, protowire.Fixed32Type) => 01010101
		data = append(data, 0x55)
		data = protowire.AppendFixed32(data, uint32(x.OptionalFixed32))
	}
	if x.OptionalFloat != 0 {
		// data = protowire.AppendTag(data, 11, protowire.Fixed32Type) => 01011101
		data = append(data, 0x5d)
		data = protowire.AppendFixed32(data, math.Float32bits(x.OptionalFloat))
	}
	if x.OptionalSfixed64 != 0 {
		// data = protowire.AppendTag(data, 12, protowire.Fixed64Type) => 01100001
		data = append(data, 0x61)
		data = protowire.AppendFixed64(data, uint64(x.OptionalSfixed64))
	}
	if x.OptionalFixed64 != 0 {
		// data = protowire.AppendTag(data, 13, protowire.Fixed64Type) => 01101001
		data = append(data, 0x69)
		data = protowire.AppendFixed64(data, uint64(x.OptionalFixed64))
	}
	if x.OptionalDouble != 0 {
		// data = protowire.AppendTag(data, 14, protowire.Fixed64Type) => 01110001
		data = append(data, 0x71)
		data = protowire.AppendFixed64(data, math.Float64bits(x.OptionalDouble))
	}
	if len(x.OptionalString) > 0 {
		// data = protowire.AppendTag(data, 15, protowire.BytesType) => 01111010
		data = append(data, 0x7a)
		data = protowire.AppendString(data, x.OptionalString)
	}
	if len(x.OptionalBytes) > 0 {
		// data = protowire.AppendTag(data, 16, protowire.BytesType) => 10000010 00000001
		data = append(data, 0x82, 0x1)
		data = protowire.AppendBytes(data, x.OptionalBytes)
	}
	if x.OptionalMessage != nil {
		// data = protowire.AppendTag(data, 17, protowire.BytesType) => 10001010 00000001
		data = append(data, 0x8a, 0x1)
		data = protowire.AppendVarint(data, uint64(x.OptionalMessage.MarshalSize()))
		data, err = x.OptionalMessage.MarshalObjectTo(data)
		if err != nil {
			return
		}
	}
	if x.OptionalMessage2 != nil {
		// data = protowire.AppendTag(data, 18, protowire.BytesType) => 10010010 00000001
		data = append(data, 0x92, 0x1)
		data = protowire.AppendVarint(data, uint64(x.OptionalMessage2.MarshalSize()))
		data, err = x.OptionalMessage2.MarshalObjectTo(data)
		if err != nil {
			return
		}
	}
	if len(x.RepeatedBool) > 0 {
		// data = protowire.AppendTag(data, 201, protowire.BytesType) => 11001010 00001100
		data = append(data, 0xca, 0xc)
		data = protowire.AppendVarint(data, uint64(len(x.RepeatedBool)))
		for _, v := range x.RepeatedBool {
			data = protowire.AppendVarint(data, protowire.EncodeBool(v))
		}
	}
	if len(x.RepeatedEnum) > 0 {
		// data = protowire.AppendTag(data, 202, protowire.BytesType) => 11010010 00001100
		data = append(data, 0xd2, 0xc)
		size := 0
		for _, v := range x.RepeatedEnum {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedEnum {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedInt32) > 0 {
		// data = protowire.AppendTag(data, 203, protowire.BytesType) => 11011010 00001100
		data = append(data, 0xda, 0xc)
		size := 0
		for _, v := range x.RepeatedInt32 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedInt32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSint32) > 0 {
		// data = protowire.AppendTag(data, 204, protowire.BytesType) => 11100010 00001100
		data = append(data, 0xe2, 0xc)
		size := 0
		for _, v := range x.RepeatedSint32 {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedSint32 {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.RepeatedUint32) > 0 {
		// data = protowire.AppendTag(data, 205, protowire.BytesType) => 11101010 00001100
		data = append(data, 0xea, 0xc)
		size := 0
		for _, v := range x.RepeatedUint32 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedUint32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedInt64) > 0 {
		// data = protowire.AppendTag(data, 206, protowire.BytesType) => 11110010 00001100
		data = append(data, 0xf2, 0xc)
		size := 0
		for _, v := range x.RepeatedInt64 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedInt64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSint64) > 0 {
		// data = protowire.AppendTag(data, 207, protowire.BytesType) => 11111010 00001100
		data = append(data, 0xfa, 0xc)
		size := 0
		for _, v := range x.RepeatedSint64 {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedSint64 {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.RepeatedUint64) > 0 {
		// data = protowire.AppendTag(data, 208, protowire.BytesType) => 10000010 00001101
		data = append(data, 0x82, 0xd)
		size := 0
		for _, v := range x.RepeatedUint64 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedUint64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSfixed32) > 0 {
		// data = protowire.AppendTag(data, 209, protowire.BytesType) => 10001010 00001101
		data = append(data, 0x8a, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedSfixed32)))
		for _, v := range x.RepeatedSfixed32 {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	if len(x.RepeatedFixed32) > 0 {
		// data = protowire.AppendTag(data, 210, protowire.BytesType) => 10010010 00001101
		data = append(data, 0x92, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedFixed32)))
		for _, v := range x.RepeatedFixed32 {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	if len(x.RepeatedFloat) > 0 {
		// data = protowire.AppendTag(data, 211, protowire.BytesType) => 10011010 00001101
		data = append(data, 0x9a, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedFloat)))
		for _, v := range x.RepeatedFloat {
			data = protowire.AppendFixed32(data, math.Float32bits(v))
		}
	}
	if len(x.RepeatedSfixed64) > 0 {
		// data = protowire.AppendTag(data, 212, protowire.BytesType) => 10100010 00001101
		data = append(data, 0xa2, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedSfixed64)))
		for _, v := range x.RepeatedSfixed64 {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.RepeatedFixed64) > 0 {
		// data = protowire.AppendTag(data, 213, protowire.BytesType) => 10101010 00001101
		data = append(data, 0xaa, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedFixed64)))
		for _, v := range x.RepeatedFixed64 {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.RepeatedDouble) > 0 {
		// data = protowire.AppendTag(data, 214, protowire.BytesType) => 10110010 00001101
		data = append(data, 0xb2, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedDouble)))
		for _, v := range x.RepeatedDouble {
			data = protowire.AppendFixed64(data, math.Float64bits(v))
		}
	}
	if len(x.RepeatedString) > 0 {
		for k := 0; k < len(x.RepeatedString); k++ {
			// data = protowire.AppendTag(data, 215, protowire.BytesType) => 10111010 00001101
			data = append(data, 0xba, 0xd)
			data = protowire.AppendString(data, x.RepeatedString[k])
		}
	}
	if len(x.RepeatedBytes) > 0 {
		for k := 0; k < len(x.RepeatedBytes); k++ {
			// data = protowire.AppendTag(data, 216, protowire.BytesType) => 11000010 00001101
			data = append(data, 0xc2, 0xd)
			data = protowire.AppendBytes(data, x.RepeatedBytes[k])
		}
	}
	if x.RepeatedMessage != nil {
		for _, item := range x.RepeatedMessage {
			// data = protowire.AppendTag(data, 217, protowire.BytesType) => 11001010 00001101
			data = append(data, 0xca, 0xd)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if x.RepeatedMessage2 != nil {
		for _, item := range x.RepeatedMessage2 {
			// data = protowire.AppendTag(data, 218, protowire.BytesType) => 11010010 00001101
			data = append(data, 0xd2, 0xd)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.NopackBool) > 0 {
		for _, item := range x.NopackBool {
			// data = protowire.AppendTag(data, 31, protowire.VarintType) => 11111000 00000001
			data = append(data, 0xf8, 0x1)
			data = protowire.AppendVarint(data, protowire.EncodeBool(item))
		}
	}
	if len(x.NopackEnum) > 0 {
		for _, item := range x.NopackEnum {
			// data = protowire.AppendTag(data, 32, protowire.VarintType) => 10000000 00000010
			data = append(data, 0x80, 0x2)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	if len(x.NopackInt32) > 0 {
		for _, item := range x.NopackInt32 {
			// data = protowire.AppendTag(data, 33, protowire.VarintType) => 10001000 00000010
			data = append(data, 0x88, 0x2)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	if len(x.NopackSint32) > 0 {
		for _, item := range x.NopackSint32 {
			// data = protowire.AppendTag(data, 34, protowire.VarintType) => 10010000 00000010
			data = append(data, 0x90, 0x2)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(item)))
		}
	}
	if len(x.NopackUint32) > 0 {
		for _, item := range x.NopackUint32 {
			// data = protowire.AppendTag(data, 35, protowire.VarintType) => 10011000 00000010
			data = append(data, 0x98, 0x2)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	if len(x.NopackInt64) > 0 {
		for _, item := range x.NopackInt64 {
			// data = protowire.AppendTag(data, 36, protowire.VarintType) => 10100000 00000010
			data = append(data, 0xa0, 0x2)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	if len(x.NopackSint64) > 0 {
		for _, item := range x.NopackSint64 {
			// data = protowire.AppendTag(data, 37, protowire.VarintType) => 10101000 00000010
			data = append(data, 0xa8, 0x2)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(item)))
		}
	}
	if len(x.NopackUint64) > 0 {
		for _, item := range x.NopackUint64 {
			// data = protowire.AppendTag(data, 38, protowire.VarintType) => 10110000 00000010
			data = append(data, 0xb0, 0x2)
			data = protowire.AppendVarint(data, uint64(item))
		}
	}
	if len(x.NopackSfixed32) > 0 {
		for _, item := range x.NopackSfixed32 {
			// data = protowire.AppendTag(data, 39, protowire.Fixed32Type) => 10111101 00000010
			data = append(data, 0xbd, 0x2)
			data = protowire.AppendFixed32(data, uint32(item))
		}
	}
	if len(x.NopackFixed32) > 0 {
		for _, item := range x.NopackFixed32 {
			// data = protowire.AppendTag(data, 40, protowire.Fixed32Type) => 11000101 00000010
			data = append(data, 0xc5, 0x2)
			data = protowire.AppendFixed32(data, uint32(item))
		}
	}
	if len(x.NopackFloat) > 0 {
		for _, item := range x.NopackFloat {
			// data = protowire.AppendTag(data, 41, protowire.Fixed32Type) => 11001101 00000010
			data = append(data, 0xcd, 0x2)
			data = protowire.AppendFixed32(data, math.Float32bits(item))
		}
	}
	if len(x.NopackSfixed64) > 0 {
		for _, item := range x.NopackSfixed64 {
			// data = protowire.AppendTag(data, 42, protowire.Fixed64Type) => 11010001 00000010
			data = append(data, 0xd1, 0x2)
			data = protowire.AppendFixed64(data, uint64(item))
		}
	}
	if len(x.NopackFixed64) > 0 {
		for _, item := range x.NopackFixed64 {
			// data = protowire.AppendTag(data, 43, protowire.Fixed64Type) => 11011001 00000010
			data = append(data, 0xd9, 0x2)
			data = protowire.AppendFixed64(data, uint64(item))
		}
	}
	if len(x.NopackDouble) > 0 {
		for _, item := range x.NopackDouble {
			// data = protowire.AppendTag(data, 44, protowire.Fixed64Type) => 11100001 00000010
			data = append(data, 0xe1, 0x2)
			data = protowire.AppendFixed64(data, math.Float64bits(item))
		}
	}
	if len(x.NopackString) > 0 {
		for k := 0; k < len(x.NopackString); k++ {
			// data = protowire.AppendTag(data, 45, protowire.BytesType) => 11101010 00000010
			data = append(data, 0xea, 0x2)
			data = protowire.AppendString(data, x.NopackString[k])
		}
	}
	if len(x.NopackBytes) > 0 {
		for k := 0; k < len(x.NopackBytes); k++ {
			// data = protowire.AppendTag(data, 46, protowire.BytesType) => 11110010 00000010
			data = append(data, 0xf2, 0x2)
			data = protowire.AppendBytes(data, x.NopackBytes[k])
		}
	}
	if x.NopackMessage != nil {
		for _, item := range x.NopackMessage {
			// data = protowire.AppendTag(data, 47, protowire.BytesType) => 11111010 00000010
			data = append(data, 0xfa, 0x2)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if x.NopackMessage2 != nil {
		for _, item := range x.NopackMessage2 {
			// data = protowire.AppendTag(data, 48, protowire.BytesType) => 10000010 00000011
			data = append(data, 0x82, 0x3)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapBool) > 0 {
		for mk, mv := range x.MapBool {
			// data = protowire.AppendTag(data, 51, protowire.BytesType) => 10011010 00000011
			data = append(data, 0x9a, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 1
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, protowire.EncodeBool(mv))
		}
	}
	if len(x.MapEnum) > 0 {
		for mk, mv := range x.MapEnum {
			// data = protowire.AppendTag(data, 52, protowire.BytesType) => 10100010 00000011
			data = append(data, 0xa2, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt32) > 0 {
		for mk, mv := range x.MapInt32 {
			// data = protowire.AppendTag(data, 53, protowire.BytesType) => 10101010 00000011
			data = append(data, 0xaa, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapUint32) > 0 {
		for mk, mv := range x.MapUint32 {
			// data = protowire.AppendTag(data, 55, protowire.BytesType) => 10111010 00000011
			data = append(data, 0xba, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt64) > 0 {
		for mk, mv := range x.MapInt64 {
			// data = protowire.AppendTag(data, 56, protowire.BytesType) => 11000010 00000011
			data = append(data, 0xc2, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapUint64) > 0 {
		for mk, mv := range x.MapUint64 {
			// data = protowire.AppendTag(data, 58, protowire.BytesType) => 11010010 00000011
			data = append(data, 0xd2, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapFloat) > 0 {
		for mk, mv := range x.MapFloat {
			// data = protowire.AppendTag(data, 61, protowire.BytesType) => 11101010 00000011
			data = append(data, 0xea, 0x3)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 4
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed32Type) => 00010101
			data = append(data, 0x15)
			data = protowire.AppendFixed32(data, math.Float32bits(mv))
		}
	}
	if len(x.MapDouble) > 0 {
		for mk, mv := range x.MapDouble {
			// data = protowire.AppendTag(data, 64, protowire.BytesType) => 10000010 00000100
			data = append(data, 0x82, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + 8
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed64Type) => 00010001
			data = append(data, 0x11)
			data = protowire.AppendFixed64(data, math.Float64bits(mv))
		}
	}
	if len(x.MapString) > 0 {
		for mk, mv := range x.MapString {
			// data = protowire.AppendTag(data, 65, protowire.BytesType) => 10001010 00000100
			data = append(data, 0x8a, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(len(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendString(data, mv)
		}
	}
	if len(x.MapBytes) > 0 {
		for mk, mv := range x.MapBytes {
			// data = protowire.AppendTag(data, 66, protowire.BytesType) => 10010010 00000100
			data = append(data, 0x92, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(len(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendBytes(data, mv)
		}
	}
	if len(x.MapMessage) > 0 {
		for mk, mv := range x.MapMessage {
			// data = protowire.AppendTag(data, 67, protowire.BytesType) => 10011010 00000100
			data = append(data, 0x9a, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapMessage2) > 0 {
		for mk, mv := range x.MapMessage2 {
			// data = protowire.AppendTag(data, 68, protowire.BytesType) => 10100010 00000100
			data = append(data, 0xa2, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapKeyInt32) > 0 {
		for mk, mv := range x.MapKeyInt32 {
			// data = protowire.AppendTag(data, 73, protowire.BytesType) => 11001010 00000100
			data = append(data, 0xca, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyUint32) > 0 {
		for mk, mv := range x.MapKeyUint32 {
			// data = protowire.AppendTag(data, 75, protowire.BytesType) => 11011010 00000100
			data = append(data, 0xda, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyInt64) > 0 {
		for mk, mv := range x.MapKeyInt64 {
			// data = protowire.AppendTag(data, 76, protowire.BytesType) => 11100010 00000100
			data = append(data, 0xe2, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyUint64) > 0 {
		for mk, mv := range x.MapKeyUint64 {
			// data = protowire.AppendTag(data, 78, protowire.BytesType) => 11110010 00000100
			data = append(data, 0xf2, 0x4)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyString) > 0 {
		for mk, mv := range x.MapKeyString {
			// data = protowire.AppendTag(data, 85, protowire.BytesType) => 10101010 00000101
			data = append(data, 0xaa, 0x5)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt32Int64) > 0 {
		for mk, mv := range x.MapInt32Int64 {
			// data = protowire.AppendTag(data, 90, protowire.BytesType) => 11010010 00000101
			data = append(data, 0xd2, 0x5)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeVarint(uint64(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapStringMessage) > 0 {
		for mk, mv := range x.MapStringMessage {
			// data = protowire.AppendTag(data, 91, protowire.BytesType) => 11011010 00000101
			data = append(data, 0xda, 0x5)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapStringMessage2) > 0 {
		for mk, mv := range x.MapStringMessage2 {
			// data = protowire.AppendTag(data, 92, protowire.BytesType) => 11100010 00000101
			data = append(data, 0xe2, 0x5)
			msize := 0
			// 1 = protowire.SizeTag(1)
			msize += 1 + protowire.SizeBytes(len(mk))
			// 1 = protowire.SizeTag(2)
			msize += 1 + protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(msize))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *FieldTestMessage) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalBool ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalBool = protowire.DecodeBool(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalEnum ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalEnum = int32(v)
		case 3:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalInt32 ID:3 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalInt32 = int32(v)
		case 4:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalSint32 ID:4 : invalid varint zigzag value")
				return
			}
			index += cnt
			x.OptionalSint32 = int32(protowire.DecodeZigZag(v))
		case 5:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalUint32 ID:5 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalUint32 = uint32(v)
		case 6:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalInt64 ID:6 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalInt64 = int64(v)
		case 7:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalSint64 ID:7 : invalid varint zigzag value")
				return
			}
			index += cnt
			x.OptionalSint64 = int64(protowire.DecodeZigZag(v))
		case 8:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalUint64 ID:8 : invalid varint value")
				return
			}
			index += cnt
			x.OptionalUint64 = uint64(v)
		case 9:
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalSfixed32 ID:9 : invalid i32 value")
				return
			}
			index += cnt
			x.OptionalSfixed32 = int32(v)
		case 10:
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalFixed32 ID:10 : invalid i32 value")
				return
			}
			index += cnt
			x.OptionalFixed32 = uint32(v)
		case 11:
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalFloat ID:11 : invalid i32 value")
				return
			}
			index += cnt
			x.OptionalFloat = math.Float32frombits(v)
		case 12:
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalSfixed64 ID:12 : invalid i64 value")
				return
			}
			index += cnt
			x.OptionalSfixed64 = int64(v)
		case 13:
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalFixed64 ID:13 : invalid i64 value")
				return
			}
			index += cnt
			x.OptionalFixed64 = uint64(v)
		case 14:
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalDouble ID:14 : invalid i64 value")
				return
			}
			index += cnt
			x.OptionalDouble = math.Float64frombits(v)
		case 15:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse FieldTestMessage.OptionalString ID:15 : invalid len value")
				return
			}
			index += cnt
			x.OptionalString = v
		case 16:
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("parse FieldTestMessage.OptionalBytes ID:16 : invalid len value")
				return
			}
			index += cnt
			x.OptionalBytes = make([]byte, len(v))
			copy(x.OptionalBytes, v)
		case 17:
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("parse FieldTestMessage.OptionalMessage ID:17 : invalid message value")
				return
			}
			index += cnt
			x.OptionalMessage = &Message1{}
			err = x.OptionalMessage.UnmarshalObject(v)
			if err != nil {
				return
			}
		case 18:
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("parse FieldTestMessage.OptionalMessage2 ID:18 : invalid message value")
				return
			}
			index += cnt
			x.OptionalMessage2 = &Message2{}
			err = x.OptionalMessage2.UnmarshalObject(v)
			if err != nil {
				return
			}
		case 201:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedBool ID:201 : invalid varint value")
					return
				}
				x.RepeatedBool = append(x.RepeatedBool, protowire.DecodeBool(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedBool ID:201 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedBool ID:201 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedBool == nil {
				x.RepeatedBool = make([]bool, 0, cnt)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedBool ID:201 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedBool = append(x.RepeatedBool, protowire.DecodeBool(v))
			}
		case 202:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedEnum ID:202 : invalid varint value")
					return
				}
				x.RepeatedEnum = append(x.RepeatedEnum, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedEnum ID:202 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedEnum ID:202 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedEnum == nil {
				x.RepeatedEnum = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedEnum ID:202 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedEnum = append(x.RepeatedEnum, int32(v))
			}
		case 203:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedInt32 ID:203 : invalid varint value")
					return
				}
				x.RepeatedInt32 = append(x.RepeatedInt32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedInt32 ID:203 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedInt32 ID:203 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedInt32 == nil {
				x.RepeatedInt32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedInt32 ID:203 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedInt32 = append(x.RepeatedInt32, int32(v))
			}
		case 204:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSint32 ID:204 : invalid varint value")
					return
				}
				x.RepeatedSint32 = append(x.RepeatedSint32, int32(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedSint32 ID:204 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedSint32 ID:204 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSint32 == nil {
				x.RepeatedSint32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSint32 ID:204 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSint32 = append(x.RepeatedSint32, int32(protowire.DecodeZigZag(v)))
			}
		case 205:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedUint32 ID:205 : invalid varint value")
					return
				}
				x.RepeatedUint32 = append(x.RepeatedUint32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedUint32 ID:205 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedUint32 ID:205 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedUint32 == nil {
				x.RepeatedUint32 = make([]uint32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedUint32 ID:205 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedUint32 = append(x.RepeatedUint32, uint32(v))
			}
		case 206:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedInt64 ID:206 : invalid varint value")
					return
				}
				x.RepeatedInt64 = append(x.RepeatedInt64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedInt64 ID:206 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedInt64 ID:206 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedInt64 == nil {
				x.RepeatedInt64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedInt64 ID:206 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedInt64 = append(x.RepeatedInt64, int64(v))
			}
		case 207:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSint64 ID:207 : invalid varint value")
					return
				}
				x.RepeatedSint64 = append(x.RepeatedSint64, int64(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedSint64 ID:207 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedSint64 ID:207 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSint64 == nil {
				x.RepeatedSint64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSint64 ID:207 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSint64 = append(x.RepeatedSint64, int64(protowire.DecodeZigZag(v)))
			}
		case 208:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedUint64 ID:208 : invalid varint value")
					return
				}
				x.RepeatedUint64 = append(x.RepeatedUint64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedUint64 ID:208 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedUint64 ID:208 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedUint64 == nil {
				x.RepeatedUint64 = make([]uint64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedUint64 ID:208 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedUint64 = append(x.RepeatedUint64, uint64(v))
			}
		case 209:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSfixed32 ID:209 : invalid varint value")
					return
				}
				x.RepeatedSfixed32 = append(x.RepeatedSfixed32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedSfixed32 ID:209 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedSfixed32 ID:209 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSfixed32 == nil {
				x.RepeatedSfixed32 = make([]int32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSfixed32 ID:209 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSfixed32 = append(x.RepeatedSfixed32, int32(v))
			}
		case 210:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFixed32 ID:210 : invalid varint value")
					return
				}
				x.RepeatedFixed32 = append(x.RepeatedFixed32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedFixed32 ID:210 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedFixed32 ID:210 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFixed32 == nil {
				x.RepeatedFixed32 = make([]uint32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFixed32 ID:210 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFixed32 = append(x.RepeatedFixed32, uint32(v))
			}
		case 211:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFloat ID:211 : invalid varint value")
					return
				}
				x.RepeatedFloat = append(x.RepeatedFloat, math.Float32frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedFloat ID:211 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedFloat ID:211 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFloat == nil {
				x.RepeatedFloat = make([]float32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFloat ID:211 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFloat = append(x.RepeatedFloat, math.Float32frombits(v))
			}
		case 212:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSfixed64 ID:212 : invalid varint value")
					return
				}
				x.RepeatedSfixed64 = append(x.RepeatedSfixed64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedSfixed64 ID:212 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedSfixed64 ID:212 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSfixed64 == nil {
				x.RepeatedSfixed64 = make([]int64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedSfixed64 ID:212 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSfixed64 = append(x.RepeatedSfixed64, int64(v))
			}
		case 213:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFixed64 ID:213 : invalid varint value")
					return
				}
				x.RepeatedFixed64 = append(x.RepeatedFixed64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedFixed64 ID:213 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedFixed64 ID:213 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFixed64 == nil {
				x.RepeatedFixed64 = make([]uint64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedFixed64 ID:213 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFixed64 = append(x.RepeatedFixed64, uint64(v))
			}
		case 214:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedDouble ID:214 : invalid varint value")
					return
				}
				x.RepeatedDouble = append(x.RepeatedDouble, math.Float64frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedDouble ID:214 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedDouble ID:214 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedDouble == nil {
				x.RepeatedDouble = make([]float64, 0, cnt/8)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.RepeatedDouble ID:214 : invalid item value")
					return
				}
				sub += cnt
				x.RepeatedDouble = append(x.RepeatedDouble, math.Float64frombits(v))
			}
		case 215:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedString ID:215 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedString ID:215 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedString == nil {
				x.RepeatedString = make([]string, 0, 2)
			}
			x.RepeatedString = append(x.RepeatedString, string(buf))
		case 216:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedBytes ID:216 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedBytes ID:216 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedBytes == nil {
				x.RepeatedBytes = make([][]byte, 0, 2)
			}
			x.RepeatedBytes = append(x.RepeatedBytes, buf)
		case 217:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedMessage ID:217 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedMessage ID:217 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedMessage == nil {
				x.RepeatedMessage = make([]*Message1, 0, 2)
			}
			item := &Message1{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.RepeatedMessage = append(x.RepeatedMessage, item)
		case 218:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.RepeatedMessage2 ID:218 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.RepeatedMessage2 ID:218 : invalid len value")
				return
			}
			index += cnt
			if x.RepeatedMessage2 == nil {
				x.RepeatedMessage2 = make([]*Message2, 0, 2)
			}
			item := &Message2{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.RepeatedMessage2 = append(x.RepeatedMessage2, item)
		case 31:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackBool ID:31 : invalid varint value")
					return
				}
				x.NopackBool = append(x.NopackBool, protowire.DecodeBool(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackBool ID:31 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackBool ID:31 : invalid len value")
				return
			}
			index += cnt
			if x.NopackBool == nil {
				x.NopackBool = make([]bool, 0, cnt)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackBool ID:31 : invalid item value")
					return
				}
				sub += cnt
				x.NopackBool = append(x.NopackBool, protowire.DecodeBool(v))
			}
		case 32:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackEnum ID:32 : invalid varint value")
					return
				}
				x.NopackEnum = append(x.NopackEnum, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackEnum ID:32 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackEnum ID:32 : invalid len value")
				return
			}
			index += cnt
			if x.NopackEnum == nil {
				x.NopackEnum = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackEnum ID:32 : invalid item value")
					return
				}
				sub += cnt
				x.NopackEnum = append(x.NopackEnum, int32(v))
			}
		case 33:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackInt32 ID:33 : invalid varint value")
					return
				}
				x.NopackInt32 = append(x.NopackInt32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackInt32 ID:33 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackInt32 ID:33 : invalid len value")
				return
			}
			index += cnt
			if x.NopackInt32 == nil {
				x.NopackInt32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackInt32 ID:33 : invalid item value")
					return
				}
				sub += cnt
				x.NopackInt32 = append(x.NopackInt32, int32(v))
			}
		case 34:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSint32 ID:34 : invalid varint value")
					return
				}
				x.NopackSint32 = append(x.NopackSint32, int32(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackSint32 ID:34 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackSint32 ID:34 : invalid len value")
				return
			}
			index += cnt
			if x.NopackSint32 == nil {
				x.NopackSint32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSint32 ID:34 : invalid item value")
					return
				}
				sub += cnt
				x.NopackSint32 = append(x.NopackSint32, int32(protowire.DecodeZigZag(v)))
			}
		case 35:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackUint32 ID:35 : invalid varint value")
					return
				}
				x.NopackUint32 = append(x.NopackUint32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackUint32 ID:35 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackUint32 ID:35 : invalid len value")
				return
			}
			index += cnt
			if x.NopackUint32 == nil {
				x.NopackUint32 = make([]uint32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackUint32 ID:35 : invalid item value")
					return
				}
				sub += cnt
				x.NopackUint32 = append(x.NopackUint32, uint32(v))
			}
		case 36:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackInt64 ID:36 : invalid varint value")
					return
				}
				x.NopackInt64 = append(x.NopackInt64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackInt64 ID:36 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackInt64 ID:36 : invalid len value")
				return
			}
			index += cnt
			if x.NopackInt64 == nil {
				x.NopackInt64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackInt64 ID:36 : invalid item value")
					return
				}
				sub += cnt
				x.NopackInt64 = append(x.NopackInt64, int64(v))
			}
		case 37:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSint64 ID:37 : invalid varint value")
					return
				}
				x.NopackSint64 = append(x.NopackSint64, int64(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackSint64 ID:37 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackSint64 ID:37 : invalid len value")
				return
			}
			index += cnt
			if x.NopackSint64 == nil {
				x.NopackSint64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSint64 ID:37 : invalid item value")
					return
				}
				sub += cnt
				x.NopackSint64 = append(x.NopackSint64, int64(protowire.DecodeZigZag(v)))
			}
		case 38:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackUint64 ID:38 : invalid varint value")
					return
				}
				x.NopackUint64 = append(x.NopackUint64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackUint64 ID:38 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackUint64 ID:38 : invalid len value")
				return
			}
			index += cnt
			if x.NopackUint64 == nil {
				x.NopackUint64 = make([]uint64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackUint64 ID:38 : invalid item value")
					return
				}
				sub += cnt
				x.NopackUint64 = append(x.NopackUint64, uint64(v))
			}
		case 39:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSfixed32 ID:39 : invalid varint value")
					return
				}
				x.NopackSfixed32 = append(x.NopackSfixed32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackSfixed32 ID:39 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackSfixed32 ID:39 : invalid len value")
				return
			}
			index += cnt
			if x.NopackSfixed32 == nil {
				x.NopackSfixed32 = make([]int32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSfixed32 ID:39 : invalid item value")
					return
				}
				sub += cnt
				x.NopackSfixed32 = append(x.NopackSfixed32, int32(v))
			}
		case 40:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFixed32 ID:40 : invalid varint value")
					return
				}
				x.NopackFixed32 = append(x.NopackFixed32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackFixed32 ID:40 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackFixed32 ID:40 : invalid len value")
				return
			}
			index += cnt
			if x.NopackFixed32 == nil {
				x.NopackFixed32 = make([]uint32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFixed32 ID:40 : invalid item value")
					return
				}
				sub += cnt
				x.NopackFixed32 = append(x.NopackFixed32, uint32(v))
			}
		case 41:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFloat ID:41 : invalid varint value")
					return
				}
				x.NopackFloat = append(x.NopackFloat, math.Float32frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackFloat ID:41 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackFloat ID:41 : invalid len value")
				return
			}
			index += cnt
			if x.NopackFloat == nil {
				x.NopackFloat = make([]float32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFloat ID:41 : invalid item value")
					return
				}
				sub += cnt
				x.NopackFloat = append(x.NopackFloat, math.Float32frombits(v))
			}
		case 42:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSfixed64 ID:42 : invalid varint value")
					return
				}
				x.NopackSfixed64 = append(x.NopackSfixed64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackSfixed64 ID:42 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackSfixed64 ID:42 : invalid len value")
				return
			}
			index += cnt
			if x.NopackSfixed64 == nil {
				x.NopackSfixed64 = make([]int64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackSfixed64 ID:42 : invalid item value")
					return
				}
				sub += cnt
				x.NopackSfixed64 = append(x.NopackSfixed64, int64(v))
			}
		case 43:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFixed64 ID:43 : invalid varint value")
					return
				}
				x.NopackFixed64 = append(x.NopackFixed64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackFixed64 ID:43 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackFixed64 ID:43 : invalid len value")
				return
			}
			index += cnt
			if x.NopackFixed64 == nil {
				x.NopackFixed64 = make([]uint64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackFixed64 ID:43 : invalid item value")
					return
				}
				sub += cnt
				x.NopackFixed64 = append(x.NopackFixed64, uint64(v))
			}
		case 44:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackDouble ID:44 : invalid varint value")
					return
				}
				x.NopackDouble = append(x.NopackDouble, math.Float64frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackDouble ID:44 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackDouble ID:44 : invalid len value")
				return
			}
			index += cnt
			if x.NopackDouble == nil {
				x.NopackDouble = make([]float64, 0, cnt/8)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("parse FieldTestMessage.NopackDouble ID:44 : invalid item value")
					return
				}
				sub += cnt
				x.NopackDouble = append(x.NopackDouble, math.Float64frombits(v))
			}
		case 45:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackString ID:45 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackString ID:45 : invalid len value")
				return
			}
			index += cnt
			if x.NopackString == nil {
				x.NopackString = make([]string, 0, 2)
			}
			x.NopackString = append(x.NopackString, string(buf))
		case 46:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackBytes ID:46 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackBytes ID:46 : invalid len value")
				return
			}
			index += cnt
			if x.NopackBytes == nil {
				x.NopackBytes = make([][]byte, 0, 2)
			}
			x.NopackBytes = append(x.NopackBytes, buf)
		case 47:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackMessage ID:47 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackMessage ID:47 : invalid len value")
				return
			}
			index += cnt
			if x.NopackMessage == nil {
				x.NopackMessage = make([]*Message1, 0, 2)
			}
			item := &Message1{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.NopackMessage = append(x.NopackMessage, item)
		case 48:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.NopackMessage2 ID:48 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.NopackMessage2 ID:48 : invalid len value")
				return
			}
			index += cnt
			if x.NopackMessage2 == nil {
				x.NopackMessage2 = make([]*Message2, 0, 2)
			}
			item := &Message2{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.NopackMessage2 = append(x.NopackMessage2, item)
		case 51:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapBool ID:51 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapBool ID:51 : invalid len value")
				return
			}
			index += cnt
			if x.MapBool == nil {
				x.MapBool = make(map[int32]bool)
			}
			var mk int32
			var mv bool
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapBool ID:51 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = protowire.DecodeBool(v)
				}
			}
			x.MapBool[mk] = mv
		case 52:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapEnum ID:52 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapEnum ID:52 : invalid len value")
				return
			}
			index += cnt
			if x.MapEnum == nil {
				x.MapEnum = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapEnum ID:52 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapEnum[mk] = mv
		case 53:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapInt32 ID:53 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapInt32 ID:53 : invalid len value")
				return
			}
			index += cnt
			if x.MapInt32 == nil {
				x.MapInt32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapInt32 ID:53 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapInt32[mk] = mv
		case 55:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapUint32 ID:55 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapUint32 ID:55 : invalid len value")
				return
			}
			index += cnt
			if x.MapUint32 == nil {
				x.MapUint32 = make(map[uint32]uint32)
			}
			var mk uint32
			var mv uint32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapUint32 ID:55 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = uint32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = uint32(v)
				}
			}
			x.MapUint32[mk] = mv
		case 56:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapInt64 ID:56 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapInt64 ID:56 : invalid len value")
				return
			}
			index += cnt
			if x.MapInt64 == nil {
				x.MapInt64 = make(map[int64]int64)
			}
			var mk int64
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapInt64 ID:56 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int64(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int64(v)
				}
			}
			x.MapInt64[mk] = mv
		case 58:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapUint64 ID:58 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapUint64 ID:58 : invalid len value")
				return
			}
			index += cnt
			if x.MapUint64 == nil {
				x.MapUint64 = make(map[uint64]uint64)
			}
			var mk uint64
			var mv uint64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapUint64 ID:58 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = uint64(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = uint64(v)
				}
			}
			x.MapUint64[mk] = mv
		case 61:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapFloat ID:61 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapFloat ID:61 : invalid len value")
				return
			}
			index += cnt
			if x.MapFloat == nil {
				x.MapFloat = make(map[int32]float32)
			}
			var mk int32
			var mv float32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapFloat ID:61 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeFixed32(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid i32 value")
						return
					}
					sindex += cnt
					mv = math.Float32frombits(v)
				}
			}
			x.MapFloat[mk] = mv
		case 64:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapDouble ID:64 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapDouble ID:64 : invalid len value")
				return
			}
			index += cnt
			if x.MapDouble == nil {
				x.MapDouble = make(map[int32]float64)
			}
			var mk int32
			var mv float64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapDouble ID:64 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeFixed64(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid i64 value")
						return
					}
					sindex += cnt
					mv = math.Float64frombits(v)
				}
			}
			x.MapDouble[mk] = mv
		case 65:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapString ID:65 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapString ID:65 : invalid len value")
				return
			}
			index += cnt
			if x.MapString == nil {
				x.MapString = make(map[int32]string)
			}
			var mk int32
			var mv string
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapString ID:65 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeString(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid len value")
						return
					}
					sindex += cnt
					mv = v
				}
			}
			x.MapString[mk] = mv
		case 66:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapBytes ID:66 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapBytes ID:66 : invalid len value")
				return
			}
			index += cnt
			if x.MapBytes == nil {
				x.MapBytes = make(map[int32][]byte)
			}
			var mk int32
			var mv []byte
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapBytes ID:66 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid len value")
						return
					}
					sindex += cnt
					mv = make([]byte, len(v))
					copy(mv, v)
				}
			}
			x.MapBytes[mk] = mv
		case 67:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapMessage ID:67 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapMessage ID:67 : invalid len value")
				return
			}
			index += cnt
			if x.MapMessage == nil {
				x.MapMessage = make(map[int32]*Message1)
			}
			var mk int32
			var mv *Message1
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapMessage ID:67 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid message value")
						return
					}
					sindex += cnt
					mv = &Message1{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapMessage[mk] = mv
		case 68:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapMessage2 ID:68 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapMessage2 ID:68 : invalid len value")
				return
			}
			index += cnt
			if x.MapMessage2 == nil {
				x.MapMessage2 = make(map[int32]*Message2)
			}
			var mk int32
			var mv *Message2
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapMessage2 ID:68 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid message value")
						return
					}
					sindex += cnt
					mv = &Message2{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapMessage2[mk] = mv
		case 73:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapKeyInt32 ID:73 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapKeyInt32 ID:73 : invalid len value")
				return
			}
			index += cnt
			if x.MapKeyInt32 == nil {
				x.MapKeyInt32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapKeyInt32 ID:73 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapKeyInt32[mk] = mv
		case 75:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapKeyUint32 ID:75 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapKeyUint32 ID:75 : invalid len value")
				return
			}
			index += cnt
			if x.MapKeyUint32 == nil {
				x.MapKeyUint32 = make(map[uint32]int32)
			}
			var mk uint32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapKeyUint32 ID:75 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = uint32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapKeyUint32[mk] = mv
		case 76:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapKeyInt64 ID:76 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapKeyInt64 ID:76 : invalid len value")
				return
			}
			index += cnt
			if x.MapKeyInt64 == nil {
				x.MapKeyInt64 = make(map[int64]int32)
			}
			var mk int64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapKeyInt64 ID:76 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int64(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapKeyInt64[mk] = mv
		case 78:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapKeyUint64 ID:78 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapKeyUint64 ID:78 : invalid len value")
				return
			}
			index += cnt
			if x.MapKeyUint64 == nil {
				x.MapKeyUint64 = make(map[uint64]int32)
			}
			var mk uint64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapKeyUint64 ID:78 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = uint64(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapKeyUint64[mk] = mv
		case 85:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapKeyString ID:85 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapKeyString ID:85 : invalid len value")
				return
			}
			index += cnt
			if x.MapKeyString == nil {
				x.MapKeyString = make(map[string]int32)
			}
			var mk string
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapKeyString ID:85 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeString(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid len value")
						return
					}
					sindex += cnt
					mk = v
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int32(v)
				}
			}
			x.MapKeyString[mk] = mv
		case 90:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapInt32Int64 ID:90 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapInt32Int64 ID:90 : invalid len value")
				return
			}
			index += cnt
			if x.MapInt32Int64 == nil {
				x.MapInt32Int64 = make(map[int32]int64)
			}
			var mk int32
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapInt32Int64 ID:90 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid varint value")
						return
					}
					sindex += cnt
					mk = int32(v)
				case 2:
					v, cnt := protowire.ConsumeVarint(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid varint value")
						return
					}
					sindex += cnt
					mv = int64(v)
				}
			}
			x.MapInt32Int64[mk] = mv
		case 91:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapStringMessage ID:91 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapStringMessage ID:91 : invalid len value")
				return
			}
			index += cnt
			if x.MapStringMessage == nil {
				x.MapStringMessage = make(map[string]*Message1)
			}
			var mk string
			var mv *Message1
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapStringMessage ID:91 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeString(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid len value")
						return
					}
					sindex += cnt
					mk = v
				case 2:
					v, cnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid message value")
						return
					}
					sindex += cnt
					mv = &Message1{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapStringMessage[mk] = mv
		case 92:
			if typ != protowire.BytesType {
				err = errors.New("parse FieldTestMessage.MapStringMessage2 ID:92 : invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("parse FieldTestMessage.MapStringMessage2 ID:92 : invalid len value")
				return
			}
			index += cnt
			if x.MapStringMessage2 == nil {
				x.MapStringMessage2 = make(map[string]*Message2)
			}
			var mk string
			var mv *Message2
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("parse FieldTestMessage.MapStringMessage2 ID:92 : invalid varint value")
					return
				}
				_ = typ
				sindex += scnt
				switch mi {
				case 1:
					v, cnt := protowire.ConsumeString(buf[sindex:])
					if cnt < 1 {
						err = errors.New("parse FieldTestMessage.Key ID:1 : invalid len value")
						return
					}
					sindex += cnt
					mk = v
				case 2:
					v, cnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("parse FieldTestMessage.Value ID:2 : invalid message value")
						return
					}
					sindex += cnt
					mv = &Message2{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapStringMessage2[mk] = mv
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *FieldTestMessage) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddBool("OptionalBool", x.OptionalBool)
	enc.AddInt32("OptionalEnum", x.OptionalEnum)
	enc.AddInt32("OptionalInt32", x.OptionalInt32)
	enc.AddInt32("OptionalSint32", x.OptionalSint32)
	enc.AddUint32("OptionalUint32", x.OptionalUint32)
	enc.AddInt64("OptionalInt64", x.OptionalInt64)
	enc.AddInt64("OptionalSint64", x.OptionalSint64)
	enc.AddUint64("OptionalUint64", x.OptionalUint64)
	enc.AddInt32("OptionalSfixed32", x.OptionalSfixed32)
	enc.AddUint32("OptionalFixed32", x.OptionalFixed32)
	enc.AddFloat32("OptionalFloat", x.OptionalFloat)
	enc.AddInt64("OptionalSfixed64", x.OptionalSfixed64)
	enc.AddUint64("OptionalFixed64", x.OptionalFixed64)
	enc.AddFloat64("OptionalDouble", x.OptionalDouble)
	enc.AddString("OptionalString", x.OptionalString)
	enc.AddBinary("OptionalBytes", x.OptionalBytes)
	enc.AddObject("OptionalMessage", x.OptionalMessage)
	enc.AddObject("OptionalMessage2", x.OptionalMessage2)
	enc.AddArray("RepeatedBool", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedBool {
			ae.AppendBool(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedEnum", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedEnum {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedInt32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedInt32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSint32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedUint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedUint32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedInt64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedInt64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSint64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedUint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedUint64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSfixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSfixed32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFixed32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFloat", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFloat {
			ae.AppendFloat32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSfixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSfixed64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFixed64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedDouble", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedDouble {
			ae.AppendFloat64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedString", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedString {
			ae.AppendString(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedBytes", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedBytes {
			ae.AppendString(base64.StdEncoding.EncodeToString(v))
		}
		return nil
	}))
	enc.AddArray("RepeatedMessage", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedMessage {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedMessage2", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedMessage2 {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddArray("NopackBool", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackBool {
			ae.AppendBool(v)
		}
		return nil
	}))
	enc.AddArray("NopackEnum", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackEnum {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("NopackInt32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackInt32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("NopackSint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackSint32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("NopackUint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackUint32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("NopackInt64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackInt64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("NopackSint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackSint64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("NopackUint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackUint64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("NopackSfixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackSfixed32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("NopackFixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackFixed32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("NopackFloat", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackFloat {
			ae.AppendFloat32(v)
		}
		return nil
	}))
	enc.AddArray("NopackSfixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackSfixed64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("NopackFixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackFixed64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("NopackDouble", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackDouble {
			ae.AppendFloat64(v)
		}
		return nil
	}))
	enc.AddArray("NopackString", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackString {
			ae.AppendString(v)
		}
		return nil
	}))
	enc.AddArray("NopackBytes", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackBytes {
			ae.AppendString(base64.StdEncoding.EncodeToString(v))
		}
		return nil
	}))
	enc.AddArray("NopackMessage", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackMessage {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddArray("NopackMessage2", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.NopackMessage2 {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddObject("MapBool", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapBool {
			oe.AddBool(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapEnum", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapEnum {
			oe.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapInt32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt32 {
			oe.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapUint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapUint32 {
			oe.AddUint32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapInt64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt64 {
			oe.AddInt64(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapUint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapUint64 {
			oe.AddUint64(strconv.FormatUint(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapFloat", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapFloat {
			oe.AddFloat32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapDouble", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapDouble {
			oe.AddFloat64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapString", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapString {
			oe.AddString(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapBytes", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapBytes {
			oe.AddBinary(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapMessage", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapMessage {
			oe.AddObject(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapMessage2", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapMessage2 {
			oe.AddObject(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyInt32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyInt32 {
			oe.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyUint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyUint32 {
			oe.AddInt32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyInt64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyInt64 {
			oe.AddInt32(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyUint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyUint64 {
			oe.AddInt32(strconv.FormatUint(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyString", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyString {
			oe.AddInt32(k, v)
		}
		return nil
	}))
	enc.AddObject("MapInt32Int64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt32Int64 {
			oe.AddInt64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapStringMessage", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapStringMessage {
			oe.AddObject(k, v)
		}
		return nil
	}))
	enc.AddObject("MapStringMessage2", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapStringMessage2 {
			oe.AddObject(k, v)
		}
		return nil
	}))
	return nil
}

type ZapArrayFieldTestMessage []*FieldTestMessage

func (x ZapArrayFieldTestMessage) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayFieldTestMessage(name string, v []*FieldTestMessage) zap.Field {
	return zap.Array(name, ZapArrayFieldTestMessage(v))
}

type ExmapleMsg struct {
	Filed int32 `json:"filed,omitempty"`
}

func (x *ExmapleMsg) Reset() {
	*x = ExmapleMsg{}
}

// MarshalObject marshal data to []byte
func (x *ExmapleMsg) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *ExmapleMsg) MarshalSize() (size int) {
	if x.Filed != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Filed))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *ExmapleMsg) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Filed != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Filed))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *ExmapleMsg) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse ExmapleMsg.Filed ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Filed = int32(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *ExmapleMsg) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("Filed", x.Filed)
	return nil
}

type ZapArrayExmapleMsg []*ExmapleMsg

func (x ZapArrayExmapleMsg) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayExmapleMsg(name string, v []*ExmapleMsg) zap.Field {
	return zap.Array(name, ZapArrayExmapleMsg(v))
}

type Message1 struct {
}

func (x *Message1) Reset() {
	*x = Message1{}
}

// MarshalObject marshal data to []byte
func (x *Message1) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *Message1) MarshalSize() (size int) {
	return
}

// MarshalObjectTo marshal data to []byte
func (x *Message1) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *Message1) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *Message1) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return nil
}

type ZapArrayMessage1 []*Message1

func (x ZapArrayMessage1) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayMessage1(name string, v []*Message1) zap.Field {
	return zap.Array(name, ZapArrayMessage1(v))
}

type Message2 struct {
	Bv bool  `json:"bv,omitempty"`
	Ev int32 `json:"ev,omitempty"`
}

func (x *Message2) Reset() {
	*x = Message2{}
}

// MarshalObject marshal data to []byte
func (x *Message2) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *Message2) MarshalSize() (size int) {
	if x.Bv {
		// 1 = protowire.SizeTag(1)
		size += 1 + 1
	}
	if x.Ev != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.Ev))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *Message2) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Bv {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, protowire.EncodeBool(x.Bv))
	}
	if x.Ev != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Ev))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *Message2) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse Message2.Bv ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Bv = protowire.DecodeBool(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse Message2.Ev ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.Ev = int32(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *Message2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddBool("Bv", x.Bv)
	enc.AddInt32("Ev", x.Ev)
	return nil
}

type ZapArrayMessage2 []*Message2

func (x ZapArrayMessage2) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayMessage2(name string, v []*Message2) zap.Field {
	return zap.Array(name, ZapArrayMessage2(v))
}
