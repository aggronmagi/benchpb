// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by protoc-gen-gopb. DO NOT EDIT.
// versions:
// 	protoc-gen-gopb 0.0.1
// 	protoc          v3.21.12
// source: fields.proto

package proto3

import (
	base64 "encoding/base64"
	errors "errors"
	zap "go.uber.org/zap"
	zapcore "go.uber.org/zap/zapcore"
	protowire "google.golang.org/protobuf/encoding/protowire"
	math "math"
	strconv "strconv"
)

type Enum int32

const (
	Enum_ZERO Enum = 0
	Enum_ONE  Enum = 1
	Enum_TWO  Enum = 2
)

// Enum value maps for Enum.
var (
	Enum_name = map[int32]string{
		0: "ZERO",
		1: "ONE",
		2: "TWO",
	}
	Enum_value = map[string]int32{
		"ZERO": 0,
		"ONE":  1,
		"TWO":  2,
	}
)

func (x Enum) Enum() *Enum {
	p := new(Enum)
	*p = x
	return p
}

func (x Enum) String() string {
	if name, ok := Enum_name[int32(x)]; ok {
		return name
	}
	return strconv.FormatInt(int64(x), 10)
}

type FieldTestMessage struct {
	OptionalBool      bool                                 `json:"optional_bool,omitempty" db:"optional_bool"`
	OptionalEnum      FieldTestMessage_Enum                `json:"optional_enum,omitempty" db:"optional_enum"`
	OptionalInt32     int32                                `json:"optional_int32,omitempty" db:"optional_int32"`
	OptionalSint32    int32                                `json:"optional_sint32,omitempty" db:"optional_sint32"`
	OptionalUint32    uint32                               `json:"optional_uint32,omitempty" db:"optional_uint32"`
	OptionalInt64     int64                                `json:"optional_int64,omitempty" db:"optional_int64"`
	OptionalSint64    int64                                `json:"optional_sint64,omitempty" db:"optional_sint64"`
	OptionalUint64    uint64                               `json:"optional_uint64,omitempty" db:"optional_uint64"`
	OptionalSfixed32  int32                                `json:"optional_sfixed32,omitempty" db:"optional_sfixed32"`
	OptionalFixed32   uint32                               `json:"optional_fixed32,omitempty" db:"optional_fixed32"`
	OptionalFloat     float32                              `json:"optional_float,omitempty" db:"optional_float"`
	OptionalSfixed64  int64                                `json:"optional_sfixed64,omitempty" db:"optional_sfixed64"`
	OptionalFixed64   uint64                               `json:"optional_fixed64,omitempty" db:"optional_fixed64"`
	OptionalDouble    float64                              `json:"optional_double,omitempty" db:"optional_double"`
	OptionalString    string                               `json:"optional_string,omitempty" db:"optional_string"`
	OptionalBytes     []byte                               `json:"optional_bytes,omitempty" db:"optional_bytes"`
	Optional_Message  *FieldTestMessage_Message            `json:"optional_Message,omitempty" db:"optional_Message"`
	Optional_Message2 *FieldTestMessage_Message2           `json:"optional_Message2,omitempty" db:"optional_Message2"`
	RepeatedBool      []bool                               `json:"repeated_bool,omitempty" db:"repeated_bool"`
	RepeatedEnum      []FieldTestMessage_Enum              `json:"repeated_enum,omitempty" db:"repeated_enum"`
	RepeatedInt32     []int32                              `json:"repeated_int32,omitempty" db:"repeated_int32"`
	RepeatedSint32    []int32                              `json:"repeated_sint32,omitempty" db:"repeated_sint32"`
	RepeatedUint32    []uint32                             `json:"repeated_uint32,omitempty" db:"repeated_uint32"`
	RepeatedInt64     []int64                              `json:"repeated_int64,omitempty" db:"repeated_int64"`
	RepeatedSint64    []int64                              `json:"repeated_sint64,omitempty" db:"repeated_sint64"`
	RepeatedUint64    []uint64                             `json:"repeated_uint64,omitempty" db:"repeated_uint64"`
	RepeatedSfixed32  []int32                              `json:"repeated_sfixed32,omitempty" db:"repeated_sfixed32"`
	RepeatedFixed32   []uint32                             `json:"repeated_fixed32,omitempty" db:"repeated_fixed32"`
	RepeatedFloat     []float32                            `json:"repeated_float,omitempty" db:"repeated_float"`
	RepeatedSfixed64  []int64                              `json:"repeated_sfixed64,omitempty" db:"repeated_sfixed64"`
	RepeatedFixed64   []uint64                             `json:"repeated_fixed64,omitempty" db:"repeated_fixed64"`
	RepeatedDouble    []float64                            `json:"repeated_double,omitempty" db:"repeated_double"`
	RepeatedString    []string                             `json:"repeated_string,omitempty" db:"repeated_string"`
	RepeatedBytes     [][]byte                             `json:"repeated_bytes,omitempty" db:"repeated_bytes"`
	Repeated_Message  []*FieldTestMessage_Message          `json:"repeated_Message,omitempty" db:"repeated_Message"`
	Repeated_Message2 []*FieldTestMessage_Message2         `json:"repeated_Message2,omitempty" db:"repeated_Message2"`
	MapBool           map[int32]bool                       `json:"map_bool,omitempty" db:"map_bool"`
	MapEnum           map[int32]FieldTestMessage_Enum      `json:"map_enum,omitempty" db:"map_enum"`
	MapInt32          map[int32]int32                      `json:"map_int32,omitempty" db:"map_int32"`
	MapSint32         map[int32]int32                      `json:"map_sint32,omitempty" db:"map_sint32"`
	MapUint32         map[uint32]uint32                    `json:"map_uint32,omitempty" db:"map_uint32"`
	MapInt64          map[int64]int64                      `json:"map_int64,omitempty" db:"map_int64"`
	MapSint64         map[int64]int64                      `json:"map_sint64,omitempty" db:"map_sint64"`
	MapUint64         map[uint64]uint64                    `json:"map_uint64,omitempty" db:"map_uint64"`
	MapSfixed32       map[int32]int32                      `json:"map_sfixed32,omitempty" db:"map_sfixed32"`
	MapFixed32        map[uint32]uint32                    `json:"map_fixed32,omitempty" db:"map_fixed32"`
	MapFloat          map[int32]float32                    `json:"map_float,omitempty" db:"map_float"`
	MapSfixed64       map[int32]int64                      `json:"map_sfixed64,omitempty" db:"map_sfixed64"`
	MapFixed64        map[int32]uint64                     `json:"map_fixed64,omitempty" db:"map_fixed64"`
	MapDouble         map[int32]float64                    `json:"map_double,omitempty" db:"map_double"`
	MapString         map[int32]string                     `json:"map_string,omitempty" db:"map_string"`
	MapBytes          map[int32][]byte                     `json:"map_bytes,omitempty" db:"map_bytes"`
	Map_Message       map[int32]*FieldTestMessage_Message  `json:"map_Message,omitempty" db:"map_Message"`
	Map_Message2      map[int32]*FieldTestMessage_Message2 `json:"map_Message2,omitempty" db:"map_Message2"`
	//	map<bool,int32> map_key_bool = 401;
	//
	// map<Enum,int32> map_key_enum = 402;
	MapKeyInt32    map[int32]int32  `json:"map_key_int32,omitempty" db:"map_key_int32"`
	MapKeySint32   map[int32]int32  `json:"map_key_sint32,omitempty" db:"map_key_sint32"`
	MapKeyUint32   map[uint32]int32 `json:"map_key_uint32,omitempty" db:"map_key_uint32"`
	MapKeyInt64    map[int64]int32  `json:"map_key_int64,omitempty" db:"map_key_int64"`
	MapKeySint64   map[int64]int32  `json:"map_key_sint64,omitempty" db:"map_key_sint64"`
	MapKeyUint64   map[uint64]int32 `json:"map_key_uint64,omitempty" db:"map_key_uint64"`
	MapKeySfixed32 map[int32]int32  `json:"map_key_sfixed32,omitempty" db:"map_key_sfixed32"`
	MapKeyFixed32  map[uint32]int32 `json:"map_key_fixed32,omitempty" db:"map_key_fixed32"`
	// map<float,int32> map_key_float = 411;
	MapKeySfixed64 map[int64]int32  `json:"map_key_sfixed64,omitempty" db:"map_key_sfixed64"`
	MapKeyFixed64  map[uint64]int32 `json:"map_key_fixed64,omitempty" db:"map_key_fixed64"`
	// map<double,int32> map_key_double = 414;
	MapKeyString      map[string]int32                      `json:"map_key_string,omitempty" db:"map_key_string"`
	MapInt32Int64     map[int32]int64                       `json:"map_int32_int64,omitempty" db:"map_int32_int64"`
	MapStringMessage  map[string]*FieldTestMessage_Message  `json:"map_string_message,omitempty" db:"map_string_message"`
	MapStringMessage2 map[string]*FieldTestMessage_Message2 `json:"map_string_message2,omitempty" db:"map_string_message2"`
	MapFixed64Enum    map[uint64]FieldTestMessage_Enum      `json:"map_fixed64_enum,omitempty" db:"map_fixed64_enum"`
}

func (x *FieldTestMessage) Reset() {
	*x = FieldTestMessage{}
}

// MarshalObjectTo marshal data to []byte
func (x *FieldTestMessage) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.OptionalBool {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, protowire.EncodeBool(x.OptionalBool))
	}
	if x.OptionalEnum != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.OptionalEnum))
	}
	if x.OptionalInt32 != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.OptionalInt32))
	}
	if x.OptionalSint32 != 0 {
		// data = protowire.AppendTag(data, 4, protowire.VarintType) => 00100000
		data = append(data, 0x20)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.OptionalSint32)))
	}
	if x.OptionalUint32 != 0 {
		// data = protowire.AppendTag(data, 5, protowire.VarintType) => 00101000
		data = append(data, 0x28)
		data = protowire.AppendVarint(data, uint64(x.OptionalUint32))
	}
	if x.OptionalInt64 != 0 {
		// data = protowire.AppendTag(data, 6, protowire.VarintType) => 00110000
		data = append(data, 0x30)
		data = protowire.AppendVarint(data, uint64(x.OptionalInt64))
	}
	if x.OptionalSint64 != 0 {
		// data = protowire.AppendTag(data, 7, protowire.VarintType) => 00111000
		data = append(data, 0x38)
		data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(x.OptionalSint64)))
	}
	if x.OptionalUint64 != 0 {
		// data = protowire.AppendTag(data, 8, protowire.VarintType) => 01000000
		data = append(data, 0x40)
		data = protowire.AppendVarint(data, uint64(x.OptionalUint64))
	}
	if x.OptionalSfixed32 != 0 {
		// data = protowire.AppendTag(data, 9, protowire.Fixed32Type) => 01001101
		data = append(data, 0x4d)
		data = protowire.AppendFixed32(data, uint32(x.OptionalSfixed32))
	}
	if x.OptionalFixed32 != 0 {
		// data = protowire.AppendTag(data, 10, protowire.Fixed32Type) => 01010101
		data = append(data, 0x55)
		data = protowire.AppendFixed32(data, uint32(x.OptionalFixed32))
	}
	if x.OptionalFloat != 0 {
		// data = protowire.AppendTag(data, 11, protowire.Fixed32Type) => 01011101
		data = append(data, 0x5d)
		data = protowire.AppendFixed32(data, math.Float32bits(x.OptionalFloat))
	}
	if x.OptionalSfixed64 != 0 {
		// data = protowire.AppendTag(data, 12, protowire.Fixed64Type) => 01100001
		data = append(data, 0x61)
		data = protowire.AppendFixed64(data, uint64(x.OptionalSfixed64))
	}
	if x.OptionalFixed64 != 0 {
		// data = protowire.AppendTag(data, 13, protowire.Fixed64Type) => 01101001
		data = append(data, 0x69)
		data = protowire.AppendFixed64(data, uint64(x.OptionalFixed64))
	}
	if x.OptionalDouble != 0 {
		// data = protowire.AppendTag(data, 14, protowire.Fixed64Type) => 01110001
		data = append(data, 0x71)
		data = protowire.AppendFixed64(data, math.Float64bits(x.OptionalDouble))
	}
	if len(x.OptionalString) > 0 {
		// data = protowire.AppendTag(data, 15, protowire.BytesType) => 01111010
		data = append(data, 0x7a)
		data = protowire.AppendString(data, x.OptionalString)
	}
	if len(x.OptionalBytes) > 0 {
		// data = protowire.AppendTag(data, 16, protowire.BytesType) => 10000010 00000001
		data = append(data, 0x82, 0x1)
		data = protowire.AppendBytes(data, x.OptionalBytes)
	}
	if x.Optional_Message != nil {
		// data = protowire.AppendTag(data, 17, protowire.BytesType) => 10001010 00000001
		data = append(data, 0x8a, 0x1)
		data = protowire.AppendVarint(data, uint64(x.Optional_Message.MarshalSize()))
		data, err = x.Optional_Message.MarshalObjectTo(data)
		if err != nil {
			return
		}
	}
	if x.Optional_Message2 != nil {
		// data = protowire.AppendTag(data, 18, protowire.BytesType) => 10010010 00000001
		data = append(data, 0x92, 0x1)
		data = protowire.AppendVarint(data, uint64(x.Optional_Message2.MarshalSize()))
		data, err = x.Optional_Message2.MarshalObjectTo(data)
		if err != nil {
			return
		}
	}
	if len(x.RepeatedBool) > 0 {
		// data = protowire.AppendTag(data, 201, protowire.BytesType) => 11001010 00001100
		data = append(data, 0xca, 0xc)
		data = protowire.AppendVarint(data, uint64(len(x.RepeatedBool)))
		for _, v := range x.RepeatedBool {
			data = protowire.AppendVarint(data, protowire.EncodeBool(v))
		}
	}
	if len(x.RepeatedEnum) > 0 {
		// data = protowire.AppendTag(data, 202, protowire.BytesType) => 11010010 00001100
		data = append(data, 0xd2, 0xc)
		size := 0
		for _, v := range x.RepeatedEnum {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedEnum {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedInt32) > 0 {
		// data = protowire.AppendTag(data, 203, protowire.BytesType) => 11011010 00001100
		data = append(data, 0xda, 0xc)
		size := 0
		for _, v := range x.RepeatedInt32 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedInt32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSint32) > 0 {
		// data = protowire.AppendTag(data, 204, protowire.BytesType) => 11100010 00001100
		data = append(data, 0xe2, 0xc)
		size := 0
		for _, v := range x.RepeatedSint32 {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedSint32 {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.RepeatedUint32) > 0 {
		// data = protowire.AppendTag(data, 205, protowire.BytesType) => 11101010 00001100
		data = append(data, 0xea, 0xc)
		size := 0
		for _, v := range x.RepeatedUint32 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedUint32 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedInt64) > 0 {
		// data = protowire.AppendTag(data, 206, protowire.BytesType) => 11110010 00001100
		data = append(data, 0xf2, 0xc)
		size := 0
		for _, v := range x.RepeatedInt64 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedInt64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSint64) > 0 {
		// data = protowire.AppendTag(data, 207, protowire.BytesType) => 11111010 00001100
		data = append(data, 0xfa, 0xc)
		size := 0
		for _, v := range x.RepeatedSint64 {
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(v)))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedSint64 {
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(v)))
		}
	}
	if len(x.RepeatedUint64) > 0 {
		// data = protowire.AppendTag(data, 208, protowire.BytesType) => 10000010 00001101
		data = append(data, 0x82, 0xd)
		size := 0
		for _, v := range x.RepeatedUint64 {
			size += protowire.SizeVarint(uint64(v))
		}
		data = protowire.AppendVarint(data, uint64(size))
		for _, v := range x.RepeatedUint64 {
			data = protowire.AppendVarint(data, uint64(v))
		}
	}
	if len(x.RepeatedSfixed32) > 0 {
		// data = protowire.AppendTag(data, 209, protowire.BytesType) => 10001010 00001101
		data = append(data, 0x8a, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedSfixed32)))
		for _, v := range x.RepeatedSfixed32 {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	if len(x.RepeatedFixed32) > 0 {
		// data = protowire.AppendTag(data, 210, protowire.BytesType) => 10010010 00001101
		data = append(data, 0x92, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedFixed32)))
		for _, v := range x.RepeatedFixed32 {
			data = protowire.AppendFixed32(data, uint32(v))
		}
	}
	if len(x.RepeatedFloat) > 0 {
		// data = protowire.AppendTag(data, 211, protowire.BytesType) => 10011010 00001101
		data = append(data, 0x9a, 0xd)
		data = protowire.AppendVarint(data, uint64(4*len(x.RepeatedFloat)))
		for _, v := range x.RepeatedFloat {
			data = protowire.AppendFixed32(data, math.Float32bits(v))
		}
	}
	if len(x.RepeatedSfixed64) > 0 {
		// data = protowire.AppendTag(data, 212, protowire.BytesType) => 10100010 00001101
		data = append(data, 0xa2, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedSfixed64)))
		for _, v := range x.RepeatedSfixed64 {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.RepeatedFixed64) > 0 {
		// data = protowire.AppendTag(data, 213, protowire.BytesType) => 10101010 00001101
		data = append(data, 0xaa, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedFixed64)))
		for _, v := range x.RepeatedFixed64 {
			data = protowire.AppendFixed64(data, uint64(v))
		}
	}
	if len(x.RepeatedDouble) > 0 {
		// data = protowire.AppendTag(data, 214, protowire.BytesType) => 10110010 00001101
		data = append(data, 0xb2, 0xd)
		data = protowire.AppendVarint(data, uint64(8*len(x.RepeatedDouble)))
		for _, v := range x.RepeatedDouble {
			data = protowire.AppendFixed64(data, math.Float64bits(v))
		}
	}
	if len(x.RepeatedString) > 0 {
		for _, item := range x.RepeatedString {
			// data = protowire.AppendTag(data, 215, protowire.BytesType) => 10111010 00001101
			data = append(data, 0xba, 0xd)
			data = protowire.AppendString(data, item)
		}
	}
	if len(x.RepeatedBytes) > 0 {
		for _, item := range x.RepeatedBytes {
			// data = protowire.AppendTag(data, 216, protowire.BytesType) => 11000010 00001101
			data = append(data, 0xc2, 0xd)
			data = protowire.AppendBytes(data, item)
		}
	}
	if len(x.Repeated_Message) > 0 {
		for _, item := range x.Repeated_Message {
			// data = protowire.AppendTag(data, 217, protowire.BytesType) => 11001010 00001101
			data = append(data, 0xca, 0xd)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.Repeated_Message2) > 0 {
		for _, item := range x.Repeated_Message2 {
			// data = protowire.AppendTag(data, 218, protowire.BytesType) => 11010010 00001101
			data = append(data, 0xd2, 0xd)
			data = protowire.AppendVarint(data, uint64(item.MarshalSize()))
			data, err = item.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapBool) > 0 {
		for mk, mv := range x.MapBool {
			// data = protowire.AppendTag(data, 301, protowire.BytesType) => 11101010 00010010
			data = append(data, 0xea, 0x12)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += 1
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, protowire.EncodeBool(mv))
		}
	}
	if len(x.MapEnum) > 0 {
		for mk, mv := range x.MapEnum {
			// data = protowire.AppendTag(data, 302, protowire.BytesType) => 11110010 00010010
			data = append(data, 0xf2, 0x12)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt32) > 0 {
		for mk, mv := range x.MapInt32 {
			// data = protowire.AppendTag(data, 303, protowire.BytesType) => 11111010 00010010
			data = append(data, 0xfa, 0x12)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapSint32) > 0 {
		for mk, mv := range x.MapSint32 {
			// data = protowire.AppendTag(data, 304, protowire.BytesType) => 10000010 00010011
			data = append(data, 0x82, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mv)))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mk)))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mv)))
		}
	}
	if len(x.MapUint32) > 0 {
		for mk, mv := range x.MapUint32 {
			// data = protowire.AppendTag(data, 305, protowire.BytesType) => 10001010 00010011
			data = append(data, 0x8a, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt64) > 0 {
		for mk, mv := range x.MapInt64 {
			// data = protowire.AppendTag(data, 306, protowire.BytesType) => 10010010 00010011
			data = append(data, 0x92, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapSint64) > 0 {
		for mk, mv := range x.MapSint64 {
			// data = protowire.AppendTag(data, 307, protowire.BytesType) => 10011010 00010011
			data = append(data, 0x9a, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mv)))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mk)))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mv)))
		}
	}
	if len(x.MapUint64) > 0 {
		for mk, mv := range x.MapUint64 {
			// data = protowire.AppendTag(data, 308, protowire.BytesType) => 10100010 00010011
			data = append(data, 0xa2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapSfixed32) > 0 {
		for mk, mv := range x.MapSfixed32 {
			// data = protowire.AppendTag(data, 309, protowire.BytesType) => 10101010 00010011
			data = append(data, 0xaa, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 4
			size += 4
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed32Type) => 00001101
			data = append(data, 0xd)
			data = protowire.AppendFixed32(data, uint32(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed32Type) => 00010101
			data = append(data, 0x15)
			data = protowire.AppendFixed32(data, uint32(mv))
		}
	}
	if len(x.MapFixed32) > 0 {
		for mk, mv := range x.MapFixed32 {
			// data = protowire.AppendTag(data, 310, protowire.BytesType) => 10110010 00010011
			data = append(data, 0xb2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 4
			size += 4
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed32Type) => 00001101
			data = append(data, 0xd)
			data = protowire.AppendFixed32(data, uint32(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed32Type) => 00010101
			data = append(data, 0x15)
			data = protowire.AppendFixed32(data, uint32(mv))
		}
	}
	if len(x.MapFloat) > 0 {
		for mk, mv := range x.MapFloat {
			// data = protowire.AppendTag(data, 311, protowire.BytesType) => 10111010 00010011
			data = append(data, 0xba, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += 4
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed32Type) => 00010101
			data = append(data, 0x15)
			data = protowire.AppendFixed32(data, math.Float32bits(mv))
		}
	}
	if len(x.MapSfixed64) > 0 {
		for mk, mv := range x.MapSfixed64 {
			// data = protowire.AppendTag(data, 312, protowire.BytesType) => 11000010 00010011
			data = append(data, 0xc2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += 8
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed64Type) => 00010001
			data = append(data, 0x11)
			data = protowire.AppendFixed64(data, uint64(mv))
		}
	}
	if len(x.MapFixed64) > 0 {
		for mk, mv := range x.MapFixed64 {
			// data = protowire.AppendTag(data, 313, protowire.BytesType) => 11001010 00010011
			data = append(data, 0xca, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += 8
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed64Type) => 00010001
			data = append(data, 0x11)
			data = protowire.AppendFixed64(data, uint64(mv))
		}
	}
	if len(x.MapDouble) > 0 {
		for mk, mv := range x.MapDouble {
			// data = protowire.AppendTag(data, 314, protowire.BytesType) => 11010010 00010011
			data = append(data, 0xd2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += 8
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.Fixed64Type) => 00010001
			data = append(data, 0x11)
			data = protowire.AppendFixed64(data, math.Float64bits(mv))
		}
	}
	if len(x.MapString) > 0 {
		for mk, mv := range x.MapString {
			// data = protowire.AppendTag(data, 315, protowire.BytesType) => 11011010 00010011
			data = append(data, 0xda, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeBytes(len(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendString(data, mv)
		}
	}
	if len(x.MapBytes) > 0 {
		for mk, mv := range x.MapBytes {
			// data = protowire.AppendTag(data, 316, protowire.BytesType) => 11100010 00010011
			data = append(data, 0xe2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeBytes(len(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendBytes(data, mv)
		}
	}
	if len(x.Map_Message) > 0 {
		for mk, mv := range x.Map_Message {
			// data = protowire.AppendTag(data, 317, protowire.BytesType) => 11101010 00010011
			data = append(data, 0xea, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.Map_Message2) > 0 {
		for mk, mv := range x.Map_Message2 {
			// data = protowire.AppendTag(data, 318, protowire.BytesType) => 11110010 00010011
			data = append(data, 0xf2, 0x13)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapKeyInt32) > 0 {
		for mk, mv := range x.MapKeyInt32 {
			// data = protowire.AppendTag(data, 403, protowire.BytesType) => 10011010 00011001
			data = append(data, 0x9a, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeySint32) > 0 {
		for mk, mv := range x.MapKeySint32 {
			// data = protowire.AppendTag(data, 404, protowire.BytesType) => 10100010 00011001
			data = append(data, 0xa2, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mk)))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyUint32) > 0 {
		for mk, mv := range x.MapKeyUint32 {
			// data = protowire.AppendTag(data, 405, protowire.BytesType) => 10101010 00011001
			data = append(data, 0xaa, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyInt64) > 0 {
		for mk, mv := range x.MapKeyInt64 {
			// data = protowire.AppendTag(data, 406, protowire.BytesType) => 10110010 00011001
			data = append(data, 0xb2, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeySint64) > 0 {
		for mk, mv := range x.MapKeySint64 {
			// data = protowire.AppendTag(data, 407, protowire.BytesType) => 10111010 00011001
			data = append(data, 0xba, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, protowire.EncodeZigZag(int64(mk)))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyUint64) > 0 {
		for mk, mv := range x.MapKeyUint64 {
			// data = protowire.AppendTag(data, 408, protowire.BytesType) => 11000010 00011001
			data = append(data, 0xc2, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeySfixed32) > 0 {
		for mk, mv := range x.MapKeySfixed32 {
			// data = protowire.AppendTag(data, 409, protowire.BytesType) => 11001010 00011001
			data = append(data, 0xca, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 4
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed32Type) => 00001101
			data = append(data, 0xd)
			data = protowire.AppendFixed32(data, uint32(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyFixed32) > 0 {
		for mk, mv := range x.MapKeyFixed32 {
			// data = protowire.AppendTag(data, 410, protowire.BytesType) => 11010010 00011001
			data = append(data, 0xd2, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 4
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed32Type) => 00001101
			data = append(data, 0xd)
			data = protowire.AppendFixed32(data, uint32(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeySfixed64) > 0 {
		for mk, mv := range x.MapKeySfixed64 {
			// data = protowire.AppendTag(data, 412, protowire.BytesType) => 11100010 00011001
			data = append(data, 0xe2, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 8
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed64Type) => 00001001
			data = append(data, 0x9)
			data = protowire.AppendFixed64(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyFixed64) > 0 {
		for mk, mv := range x.MapKeyFixed64 {
			// data = protowire.AppendTag(data, 413, protowire.BytesType) => 11101010 00011001
			data = append(data, 0xea, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 8
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed64Type) => 00001001
			data = append(data, 0x9)
			data = protowire.AppendFixed64(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapKeyString) > 0 {
		for mk, mv := range x.MapKeyString {
			// data = protowire.AppendTag(data, 415, protowire.BytesType) => 11111010 00011001
			data = append(data, 0xfa, 0x19)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeBytes(len(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapInt32Int64) > 0 {
		for mk, mv := range x.MapInt32Int64 {
			// data = protowire.AppendTag(data, 500, protowire.BytesType) => 10100010 00011111
			data = append(data, 0xa2, 0x1f)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeVarint(uint64(mk))
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
			data = append(data, 0x8)
			data = protowire.AppendVarint(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	if len(x.MapStringMessage) > 0 {
		for mk, mv := range x.MapStringMessage {
			// data = protowire.AppendTag(data, 501, protowire.BytesType) => 10101010 00011111
			data = append(data, 0xaa, 0x1f)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeBytes(len(mk))
			size += protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapStringMessage2) > 0 {
		for mk, mv := range x.MapStringMessage2 {
			// data = protowire.AppendTag(data, 502, protowire.BytesType) => 10110010 00011111
			data = append(data, 0xb2, 0x1f)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += protowire.SizeBytes(len(mk))
			size += protowire.SizeBytes(mv.MarshalSize())
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.BytesType) => 00001010
			data = append(data, 0xa)
			data = protowire.AppendString(data, mk)
			// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
			data = append(data, 0x12)
			data = protowire.AppendVarint(data, uint64(mv.MarshalSize()))
			data, err = mv.MarshalObjectTo(data)
			if err != nil {
				return
			}
		}
	}
	if len(x.MapFixed64Enum) > 0 {
		for mk, mv := range x.MapFixed64Enum {
			// data = protowire.AppendTag(data, 503, protowire.BytesType) => 10111010 00011111
			data = append(data, 0xba, 0x1f)
			size := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			size += 8
			size += protowire.SizeVarint(uint64(mv))
			data = protowire.AppendVarint(data, uint64(size))
			// data = protowire.AppendTag(data, 1, protowire.Fixed64Type) => 00001001
			data = append(data, 0x9)
			data = protowire.AppendFixed64(data, uint64(mk))
			// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
			data = append(data, 0x10)
			data = protowire.AppendVarint(data, uint64(mv))
		}
	}
	return
}

// MarshalObject marshal data to []byte
func (x *FieldTestMessage) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// UnmarshalObject unmarshal data from []byte
func (x *FieldTestMessage) UnmarshalObject(data []byte) (err error) {
	index := 0
	ignoreGroup := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		// ignore group
		if ignoreGroup > 0 {
			switch typ {
			case protowire.VarintType:
				_, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = protowire.ParseError(cnt)
					return
				}
				index += cnt
			case protowire.Fixed32Type:
				index += 4
			case protowire.Fixed64Type:
				index += 8
			case protowire.BytesType:
				v, cnt := protowire.ConsumeBytes(data[index:])
				if v == nil {
					if cnt < 0 {
						err = protowire.ParseError(cnt)
					} else {
						err = errors.New("invalid data")
					}
					return
				}
				index += cnt
			case protowire.StartGroupType:
				ignoreGroup++
			case protowire.EndGroupType:
				ignoreGroup--
			}
			continue
		}
		switch num {
		case 1:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalBool id:1. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalBool id:1. invalid varint value")
				return
			}
			index += cnt
			x.OptionalBool = protowire.DecodeBool(v)
		case 2:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalEnum id:2. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalEnum id:2. invalid varint value")
				return
			}
			index += cnt
			x.OptionalEnum = FieldTestMessage_Enum(v)
		case 3:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalInt32 id:3. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalInt32 id:3. invalid varint value")
				return
			}
			index += cnt
			x.OptionalInt32 = int32(v)
		case 4:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalSint32 id:4. not varint zigzag type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalSint32 id:4. invalid varint zigzag value")
				return
			}
			index += cnt
			x.OptionalSint32 = int32(protowire.DecodeZigZag(v))
		case 5:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalUint32 id:5. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalUint32 id:5. invalid varint value")
				return
			}
			index += cnt
			x.OptionalUint32 = uint32(v)
		case 6:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalInt64 id:6. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalInt64 id:6. invalid varint value")
				return
			}
			index += cnt
			x.OptionalInt64 = int64(v)
		case 7:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalSint64 id:7. not varint zigzag type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalSint64 id:7. invalid varint zigzag value")
				return
			}
			index += cnt
			x.OptionalSint64 = int64(protowire.DecodeZigZag(v))
		case 8:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage.OptionalUint64 id:8. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalUint64 id:8. invalid varint value")
				return
			}
			index += cnt
			x.OptionalUint64 = uint64(v)
		case 9:
			if typ != protowire.Fixed32Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalSfixed32 id:9. not i32 type")
				return
			}
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalSfixed32 id:9. invalid i32 value")
				return
			}
			index += cnt
			x.OptionalSfixed32 = int32(v)
		case 10:
			if typ != protowire.Fixed32Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalFixed32 id:10. not i32 type")
				return
			}
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalFixed32 id:10. invalid i32 value")
				return
			}
			index += cnt
			x.OptionalFixed32 = uint32(v)
		case 11:
			if typ != protowire.Fixed32Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalFloat id:11. not i32 type")
				return
			}
			v, cnt := protowire.ConsumeFixed32(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalFloat id:11. invalid i32 value")
				return
			}
			index += cnt
			x.OptionalFloat = math.Float32frombits(v)
		case 12:
			if typ != protowire.Fixed64Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalSfixed64 id:12. not i64 type")
				return
			}
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalSfixed64 id:12. invalid i64 value")
				return
			}
			index += cnt
			x.OptionalSfixed64 = int64(v)
		case 13:
			if typ != protowire.Fixed64Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalFixed64 id:13. not i64 type")
				return
			}
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalFixed64 id:13. invalid i64 value")
				return
			}
			index += cnt
			x.OptionalFixed64 = uint64(v)
		case 14:
			if typ != protowire.Fixed64Type {
				err = errors.New("invlaid field FieldTestMessage.OptionalDouble id:14. not i64 type")
				return
			}
			v, cnt := protowire.ConsumeFixed64(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalDouble id:14. invalid i64 value")
				return
			}
			index += cnt
			x.OptionalDouble = math.Float64frombits(v)
		case 15:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.OptionalString id:15. not len type")
				return
			}
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage.OptionalString id:15. invalid len value")
				return
			}
			index += cnt
			x.OptionalString = v
		case 16:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.OptionalBytes id:16. not len type")
				return
			}
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("invlaid field FieldTestMessage.OptionalBytes id:16. invalid len value")
				return
			}
			index += cnt
			x.OptionalBytes = make([]byte, len(v))
			copy(x.OptionalBytes, v)
		case 17:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Optional_Message id:17. not message type")
				return
			}
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("invlaid field FieldTestMessage.Optional_Message id:17. invalid message value")
				return
			}
			index += cnt
			x.Optional_Message = &FieldTestMessage_Message{}
			err = x.Optional_Message.UnmarshalObject(v)
			if err != nil {
				return
			}
		case 18:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Optional_Message2 id:18. not message type")
				return
			}
			v, cnt := protowire.ConsumeBytes(data[index:])
			if v == nil {
				err = errors.New("invlaid field FieldTestMessage.Optional_Message2 id:18. invalid message value")
				return
			}
			index += cnt
			x.Optional_Message2 = &FieldTestMessage_Message2{}
			err = x.Optional_Message2.UnmarshalObject(v)
			if err != nil {
				return
			}
		case 201:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedBool id:201. invalid varint value")
					return
				}
				x.RepeatedBool = append(x.RepeatedBool, protowire.DecodeBool(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedBool id:201. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedBool id:201. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedBool == nil {
				x.RepeatedBool = make([]bool, 0, cnt)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedBool id:201. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedBool = append(x.RepeatedBool, protowire.DecodeBool(v))
			}
		case 202:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedEnum id:202. invalid varint value")
					return
				}
				x.RepeatedEnum = append(x.RepeatedEnum, FieldTestMessage_Enum(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedEnum id:202. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedEnum id:202. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedEnum == nil {
				x.RepeatedEnum = make([]FieldTestMessage_Enum, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedEnum id:202. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedEnum = append(x.RepeatedEnum, FieldTestMessage_Enum(v))
			}
		case 203:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedInt32 id:203. invalid varint value")
					return
				}
				x.RepeatedInt32 = append(x.RepeatedInt32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedInt32 id:203. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedInt32 id:203. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedInt32 == nil {
				x.RepeatedInt32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedInt32 id:203. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedInt32 = append(x.RepeatedInt32, int32(v))
			}
		case 204:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSint32 id:204. invalid varint value")
					return
				}
				x.RepeatedSint32 = append(x.RepeatedSint32, int32(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSint32 id:204. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSint32 id:204. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSint32 == nil {
				x.RepeatedSint32 = make([]int32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSint32 id:204. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSint32 = append(x.RepeatedSint32, int32(protowire.DecodeZigZag(v)))
			}
		case 205:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedUint32 id:205. invalid varint value")
					return
				}
				x.RepeatedUint32 = append(x.RepeatedUint32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedUint32 id:205. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedUint32 id:205. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedUint32 == nil {
				x.RepeatedUint32 = make([]uint32, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedUint32 id:205. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedUint32 = append(x.RepeatedUint32, uint32(v))
			}
		case 206:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedInt64 id:206. invalid varint value")
					return
				}
				x.RepeatedInt64 = append(x.RepeatedInt64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedInt64 id:206. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedInt64 id:206. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedInt64 == nil {
				x.RepeatedInt64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedInt64 id:206. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedInt64 = append(x.RepeatedInt64, int64(v))
			}
		case 207:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSint64 id:207. invalid varint value")
					return
				}
				x.RepeatedSint64 = append(x.RepeatedSint64, int64(protowire.DecodeZigZag(v)))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSint64 id:207. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSint64 id:207. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSint64 == nil {
				x.RepeatedSint64 = make([]int64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSint64 id:207. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSint64 = append(x.RepeatedSint64, int64(protowire.DecodeZigZag(v)))
			}
		case 208:
			// packed=false
			if typ == protowire.VarintType {
				v, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedUint64 id:208. invalid varint value")
					return
				}
				x.RepeatedUint64 = append(x.RepeatedUint64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedUint64 id:208. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedUint64 id:208. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedUint64 == nil {
				x.RepeatedUint64 = make([]uint64, 0, 2)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeVarint(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedUint64 id:208. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedUint64 = append(x.RepeatedUint64, uint64(v))
			}
		case 209:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed32 id:209. invalid varint value")
					return
				}
				x.RepeatedSfixed32 = append(x.RepeatedSfixed32, int32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed32 id:209. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed32 id:209. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSfixed32 == nil {
				x.RepeatedSfixed32 = make([]int32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed32 id:209. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSfixed32 = append(x.RepeatedSfixed32, int32(v))
			}
		case 210:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFixed32 id:210. invalid varint value")
					return
				}
				x.RepeatedFixed32 = append(x.RepeatedFixed32, uint32(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFixed32 id:210. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFixed32 id:210. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFixed32 == nil {
				x.RepeatedFixed32 = make([]uint32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFixed32 id:210. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFixed32 = append(x.RepeatedFixed32, uint32(v))
			}
		case 211:
			// packed=false
			if typ == protowire.Fixed32Type {
				v, cnt := protowire.ConsumeFixed32(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFloat id:211. invalid varint value")
					return
				}
				x.RepeatedFloat = append(x.RepeatedFloat, math.Float32frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFloat id:211. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFloat id:211. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFloat == nil {
				x.RepeatedFloat = make([]float32, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed32(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFloat id:211. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFloat = append(x.RepeatedFloat, math.Float32frombits(v))
			}
		case 212:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed64 id:212. invalid varint value")
					return
				}
				x.RepeatedSfixed64 = append(x.RepeatedSfixed64, int64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed64 id:212. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed64 id:212. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedSfixed64 == nil {
				x.RepeatedSfixed64 = make([]int64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedSfixed64 id:212. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedSfixed64 = append(x.RepeatedSfixed64, int64(v))
			}
		case 213:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFixed64 id:213. invalid varint value")
					return
				}
				x.RepeatedFixed64 = append(x.RepeatedFixed64, uint64(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFixed64 id:213. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedFixed64 id:213. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedFixed64 == nil {
				x.RepeatedFixed64 = make([]uint64, 0, cnt/4)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedFixed64 id:213. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedFixed64 = append(x.RepeatedFixed64, uint64(v))
			}
		case 214:
			// packed=false
			if typ == protowire.Fixed64Type {
				v, cnt := protowire.ConsumeFixed64(data[index:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedDouble id:214. invalid varint value")
					return
				}
				x.RepeatedDouble = append(x.RepeatedDouble, math.Float64frombits(v))
				index += cnt
				continue
			}
			// packed = true
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedDouble id:214. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedDouble id:214. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedDouble == nil {
				x.RepeatedDouble = make([]float64, 0, cnt/8)
			}
			sub := 0
			for sub < len(buf) {
				v, cnt := protowire.ConsumeFixed64(buf[sub:])
				if cnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.RepeatedDouble id:214. invalid item value")
					return
				}
				sub += cnt
				x.RepeatedDouble = append(x.RepeatedDouble, math.Float64frombits(v))
			}
		case 215:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedString id:215. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedString id:215. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedString == nil {
				x.RepeatedString = make([]string, 0, 2)
			}
			x.RepeatedString = append(x.RepeatedString, string(buf))
		case 216:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.RepeatedBytes id:216. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.RepeatedBytes id:216. invalid len value")
				return
			}
			index += cnt
			if x.RepeatedBytes == nil {
				x.RepeatedBytes = make([][]byte, 0, 2)
			}
			x.RepeatedBytes = append(x.RepeatedBytes, buf)
		case 217:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Repeated_Message id:217. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.Repeated_Message id:217. invalid len value")
				return
			}
			index += cnt
			if x.Repeated_Message == nil {
				x.Repeated_Message = make([]*FieldTestMessage_Message, 0, 2)
			}
			item := &FieldTestMessage_Message{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.Repeated_Message = append(x.Repeated_Message, item)
		case 218:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Repeated_Message2 id:218. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.Repeated_Message2 id:218. invalid len value")
				return
			}
			index += cnt
			if x.Repeated_Message2 == nil {
				x.Repeated_Message2 = make([]*FieldTestMessage_Message2, 0, 2)
			}
			item := &FieldTestMessage_Message2{}
			err = item.UnmarshalObject(buf)
			if err != nil {
				return
			}
			x.Repeated_Message2 = append(x.Repeated_Message2, item)
		case 301:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapBool id:301. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapBool id:301. invalid len value")
				return
			}
			index += cnt
			if x.MapBool == nil {
				x.MapBool = make(map[int32]bool)
			}
			var mk int32
			var mv bool
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapBool id:301. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = protowire.DecodeBool(v)
				}
			}
			x.MapBool[mk] = mv
		case 302:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapEnum id:302. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapEnum id:302. invalid len value")
				return
			}
			index += cnt
			if x.MapEnum == nil {
				x.MapEnum = make(map[int32]FieldTestMessage_Enum)
			}
			var mk int32
			var mv FieldTestMessage_Enum
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapEnum id:302. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = FieldTestMessage_Enum(v)
				}
			}
			x.MapEnum[mk] = mv
		case 303:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapInt32 id:303. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapInt32 id:303. invalid len value")
				return
			}
			index += cnt
			if x.MapInt32 == nil {
				x.MapInt32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapInt32 id:303. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapInt32[mk] = mv
		case 304:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapSint32 id:304. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapSint32 id:304. invalid len value")
				return
			}
			index += cnt
			if x.MapSint32 == nil {
				x.MapSint32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapSint32 id:304. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mk = int32(protowire.DecodeZigZag(v))
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mv = int32(protowire.DecodeZigZag(v))
				}
			}
			x.MapSint32[mk] = mv
		case 305:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapUint32 id:305. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapUint32 id:305. invalid len value")
				return
			}
			index += cnt
			if x.MapUint32 == nil {
				x.MapUint32 = make(map[uint32]uint32)
			}
			var mk uint32
			var mv uint32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapUint32 id:305. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = uint32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = uint32(v)
				}
			}
			x.MapUint32[mk] = mv
		case 306:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapInt64 id:306. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapInt64 id:306. invalid len value")
				return
			}
			index += cnt
			if x.MapInt64 == nil {
				x.MapInt64 = make(map[int64]int64)
			}
			var mk int64
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapInt64 id:306. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int64(v)
				}
			}
			x.MapInt64[mk] = mv
		case 307:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapSint64 id:307. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapSint64 id:307. invalid len value")
				return
			}
			index += cnt
			if x.MapSint64 == nil {
				x.MapSint64 = make(map[int64]int64)
			}
			var mk int64
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapSint64 id:307. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mk = int64(protowire.DecodeZigZag(v))
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mv = int64(protowire.DecodeZigZag(v))
				}
			}
			x.MapSint64[mk] = mv
		case 308:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapUint64 id:308. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapUint64 id:308. invalid len value")
				return
			}
			index += cnt
			if x.MapUint64 == nil {
				x.MapUint64 = make(map[uint64]uint64)
			}
			var mk uint64
			var mv uint64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapUint64 id:308. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = uint64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = uint64(v)
				}
			}
			x.MapUint64[mk] = mv
		case 309:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapSfixed32 id:309. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapSfixed32 id:309. invalid len value")
				return
			}
			index += cnt
			if x.MapSfixed32 == nil {
				x.MapSfixed32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapSfixed32 id:309. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i32 value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i32 value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapSfixed32[mk] = mv
		case 310:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapFixed32 id:310. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapFixed32 id:310. invalid len value")
				return
			}
			index += cnt
			if x.MapFixed32 == nil {
				x.MapFixed32 = make(map[uint32]uint32)
			}
			var mk uint32
			var mv uint32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapFixed32 id:310. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i32 value")
						return
					}
					sindex += scnt
					mk = uint32(v)
				case 2:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i32 value")
						return
					}
					sindex += scnt
					mv = uint32(v)
				}
			}
			x.MapFixed32[mk] = mv
		case 311:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapFloat id:311. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapFloat id:311. invalid len value")
				return
			}
			index += cnt
			if x.MapFloat == nil {
				x.MapFloat = make(map[int32]float32)
			}
			var mk int32
			var mv float32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapFloat id:311. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i32 value")
						return
					}
					sindex += scnt
					mv = math.Float32frombits(v)
				}
			}
			x.MapFloat[mk] = mv
		case 312:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapSfixed64 id:312. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapSfixed64 id:312. invalid len value")
				return
			}
			index += cnt
			if x.MapSfixed64 == nil {
				x.MapSfixed64 = make(map[int32]int64)
			}
			var mk int32
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapSfixed64 id:312. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i64 value")
						return
					}
					sindex += scnt
					mv = int64(v)
				}
			}
			x.MapSfixed64[mk] = mv
		case 313:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapFixed64 id:313. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapFixed64 id:313. invalid len value")
				return
			}
			index += cnt
			if x.MapFixed64 == nil {
				x.MapFixed64 = make(map[int32]uint64)
			}
			var mk int32
			var mv uint64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapFixed64 id:313. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i64 value")
						return
					}
					sindex += scnt
					mv = uint64(v)
				}
			}
			x.MapFixed64[mk] = mv
		case 314:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapDouble id:314. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapDouble id:314. invalid len value")
				return
			}
			index += cnt
			if x.MapDouble == nil {
				x.MapDouble = make(map[int32]float64)
			}
			var mk int32
			var mv float64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapDouble id:314. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid i64 value")
						return
					}
					sindex += scnt
					mv = math.Float64frombits(v)
				}
			}
			x.MapDouble[mk] = mv
		case 315:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapString id:315. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapString id:315. invalid len value")
				return
			}
			index += cnt
			if x.MapString == nil {
				x.MapString = make(map[int32]string)
			}
			var mk int32
			var mv string
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapString id:315. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not len type")
						return
					}
					v, scnt := protowire.ConsumeString(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid len value")
						return
					}
					sindex += scnt
					mv = v
				}
			}
			x.MapString[mk] = mv
		case 316:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapBytes id:316. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapBytes id:316. invalid len value")
				return
			}
			index += cnt
			if x.MapBytes == nil {
				x.MapBytes = make(map[int32][]byte)
			}
			var mk int32
			var mv []byte
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapBytes id:316. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not len type")
						return
					}
					v, scnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid len value")
						return
					}
					sindex += scnt
					mv = make([]byte, len(v))
					copy(mv, v)
				}
			}
			x.MapBytes[mk] = mv
		case 317:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Map_Message id:317. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.Map_Message id:317. invalid len value")
				return
			}
			index += cnt
			if x.Map_Message == nil {
				x.Map_Message = make(map[int32]*FieldTestMessage_Message)
			}
			var mk int32
			var mv *FieldTestMessage_Message
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.Map_Message id:317. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not message type")
						return
					}
					v, scnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid message value")
						return
					}
					sindex += scnt
					mv = &FieldTestMessage_Message{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.Map_Message[mk] = mv
		case 318:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.Map_Message2 id:318. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.Map_Message2 id:318. invalid len value")
				return
			}
			index += cnt
			if x.Map_Message2 == nil {
				x.Map_Message2 = make(map[int32]*FieldTestMessage_Message2)
			}
			var mk int32
			var mv *FieldTestMessage_Message2
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.Map_Message2 id:318. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not message type")
						return
					}
					v, scnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid message value")
						return
					}
					sindex += scnt
					mv = &FieldTestMessage_Message2{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.Map_Message2[mk] = mv
		case 403:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyInt32 id:403. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyInt32 id:403. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyInt32 == nil {
				x.MapKeyInt32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyInt32 id:403. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyInt32[mk] = mv
		case 404:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeySint32 id:404. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeySint32 id:404. invalid len value")
				return
			}
			index += cnt
			if x.MapKeySint32 == nil {
				x.MapKeySint32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeySint32 id:404. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mk = int32(protowire.DecodeZigZag(v))
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeySint32[mk] = mv
		case 405:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyUint32 id:405. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyUint32 id:405. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyUint32 == nil {
				x.MapKeyUint32 = make(map[uint32]int32)
			}
			var mk uint32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyUint32 id:405. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = uint32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyUint32[mk] = mv
		case 406:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyInt64 id:406. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyInt64 id:406. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyInt64 == nil {
				x.MapKeyInt64 = make(map[int64]int32)
			}
			var mk int64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyInt64 id:406. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyInt64[mk] = mv
		case 407:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeySint64 id:407. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeySint64 id:407. invalid len value")
				return
			}
			index += cnt
			if x.MapKeySint64 == nil {
				x.MapKeySint64 = make(map[int64]int32)
			}
			var mk int64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeySint64 id:407. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint zigzag type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint zigzag value")
						return
					}
					sindex += scnt
					mk = int64(protowire.DecodeZigZag(v))
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeySint64[mk] = mv
		case 408:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyUint64 id:408. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyUint64 id:408. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyUint64 == nil {
				x.MapKeyUint64 = make(map[uint64]int32)
			}
			var mk uint64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyUint64 id:408. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = uint64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyUint64[mk] = mv
		case 409:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeySfixed32 id:409. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeySfixed32 id:409. invalid len value")
				return
			}
			index += cnt
			if x.MapKeySfixed32 == nil {
				x.MapKeySfixed32 = make(map[int32]int32)
			}
			var mk int32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeySfixed32 id:409. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i32 value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeySfixed32[mk] = mv
		case 410:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyFixed32 id:410. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyFixed32 id:410. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyFixed32 == nil {
				x.MapKeyFixed32 = make(map[uint32]int32)
			}
			var mk uint32
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyFixed32 id:410. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed32Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i32 type")
						return
					}
					v, scnt := protowire.ConsumeFixed32(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i32 value")
						return
					}
					sindex += scnt
					mk = uint32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyFixed32[mk] = mv
		case 412:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeySfixed64 id:412. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeySfixed64 id:412. invalid len value")
				return
			}
			index += cnt
			if x.MapKeySfixed64 == nil {
				x.MapKeySfixed64 = make(map[int64]int32)
			}
			var mk int64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeySfixed64 id:412. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i64 value")
						return
					}
					sindex += scnt
					mk = int64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeySfixed64[mk] = mv
		case 413:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyFixed64 id:413. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyFixed64 id:413. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyFixed64 == nil {
				x.MapKeyFixed64 = make(map[uint64]int32)
			}
			var mk uint64
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyFixed64 id:413. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i64 value")
						return
					}
					sindex += scnt
					mk = uint64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyFixed64[mk] = mv
		case 415:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapKeyString id:415. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapKeyString id:415. invalid len value")
				return
			}
			index += cnt
			if x.MapKeyString == nil {
				x.MapKeyString = make(map[string]int32)
			}
			var mk string
			var mv int32
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapKeyString id:415. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not len type")
						return
					}
					v, scnt := protowire.ConsumeString(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid len value")
						return
					}
					sindex += scnt
					mk = v
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int32(v)
				}
			}
			x.MapKeyString[mk] = mv
		case 500:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapInt32Int64 id:500. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapInt32Int64 id:500. invalid len value")
				return
			}
			index += cnt
			if x.MapInt32Int64 == nil {
				x.MapInt32Int64 = make(map[int32]int64)
			}
			var mk int32
			var mv int64
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapInt32Int64 id:500. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid varint value")
						return
					}
					sindex += scnt
					mk = int32(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = int64(v)
				}
			}
			x.MapInt32Int64[mk] = mv
		case 501:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapStringMessage id:501. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapStringMessage id:501. invalid len value")
				return
			}
			index += cnt
			if x.MapStringMessage == nil {
				x.MapStringMessage = make(map[string]*FieldTestMessage_Message)
			}
			var mk string
			var mv *FieldTestMessage_Message
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapStringMessage id:501. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not len type")
						return
					}
					v, scnt := protowire.ConsumeString(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid len value")
						return
					}
					sindex += scnt
					mk = v
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not message type")
						return
					}
					v, scnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid message value")
						return
					}
					sindex += scnt
					mv = &FieldTestMessage_Message{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapStringMessage[mk] = mv
		case 502:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapStringMessage2 id:502. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapStringMessage2 id:502. invalid len value")
				return
			}
			index += cnt
			if x.MapStringMessage2 == nil {
				x.MapStringMessage2 = make(map[string]*FieldTestMessage_Message2)
			}
			var mk string
			var mv *FieldTestMessage_Message2
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapStringMessage2 id:502. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not len type")
						return
					}
					v, scnt := protowire.ConsumeString(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid len value")
						return
					}
					sindex += scnt
					mk = v
				case 2:
					if typ != protowire.BytesType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not message type")
						return
					}
					v, scnt := protowire.ConsumeBytes(buf[sindex:])
					if v == nil {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid message value")
						return
					}
					sindex += scnt
					mv = &FieldTestMessage_Message2{}
					err = mv.UnmarshalObject(v)
					if err != nil {
						return
					}
				}
			}
			x.MapStringMessage2[mk] = mv
		case 503:
			if typ != protowire.BytesType {
				err = errors.New("invlaid field FieldTestMessage.MapFixed64Enum id:503. invalid repeated tag value")
				return
			}
			buf, cnt := protowire.ConsumeBytes(data[index:])
			if buf == nil {
				err = errors.New("invlaid field FieldTestMessage.MapFixed64Enum id:503. invalid len value")
				return
			}
			index += cnt
			if x.MapFixed64Enum == nil {
				x.MapFixed64Enum = make(map[uint64]FieldTestMessage_Enum)
			}
			var mk uint64
			var mv FieldTestMessage_Enum
			for sindex := 0; sindex < len(buf); {
				mi, typ, scnt := protowire.ConsumeTag(buf[sindex:])
				if scnt < 1 {
					err = errors.New("invlaid field FieldTestMessage.MapFixed64Enum id:503. invalid varint value")
					return
				}
				sindex += scnt
				switch mi {
				case 1:
					if typ != protowire.Fixed64Type {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. not i64 type")
						return
					}
					v, scnt := protowire.ConsumeFixed64(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Key id:1. invalid i64 value")
						return
					}
					sindex += scnt
					mk = uint64(v)
				case 2:
					if typ != protowire.VarintType {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. not varint type")
						return
					}
					v, scnt := protowire.ConsumeVarint(buf[sindex:])
					if scnt < 1 {
						err = errors.New("invlaid field FieldTestMessage.Value id:2. invalid varint value")
						return
					}
					sindex += scnt
					mv = FieldTestMessage_Enum(v)
				}
			}
			x.MapFixed64Enum[mk] = mv
		default: // skip fields
			switch typ {
			case protowire.VarintType:
				_, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = protowire.ParseError(cnt)
					return
				}
				index += cnt
			case protowire.Fixed32Type:
				index += 4
			case protowire.Fixed64Type:
				index += 8
			case protowire.BytesType:
				v, cnt := protowire.ConsumeBytes(data[index:])
				if v == nil {
					if cnt < 0 {
						err = protowire.ParseError(cnt)
					} else {
						err = errors.New("invalid data")
					}
					return
				}
				index += cnt
			case protowire.StartGroupType:
				ignoreGroup++
			case protowire.EndGroupType:
				ignoreGroup--
			}
		}
	}

	return
}

// MarshalSize calc marshal data need space
func (x *FieldTestMessage) MarshalSize() (size int) {
	if x.OptionalBool {
		size += 1 // size += protowire.SizeTag(,1)
		size += 1
	}
	if x.OptionalEnum != 0 {
		size += 1 // size += protowire.SizeTag(,2)
		size += protowire.SizeVarint(uint64(x.OptionalEnum))
	}
	if x.OptionalInt32 != 0 {
		size += 1 // size += protowire.SizeTag(,3)
		size += protowire.SizeVarint(uint64(x.OptionalInt32))
	}
	if x.OptionalSint32 != 0 {
		size += 1 // size += protowire.SizeTag(,4)
		size += protowire.SizeVarint(protowire.EncodeZigZag(int64(x.OptionalSint32)))
	}
	if x.OptionalUint32 != 0 {
		size += 1 // size += protowire.SizeTag(,5)
		size += protowire.SizeVarint(uint64(x.OptionalUint32))
	}
	if x.OptionalInt64 != 0 {
		size += 1 // size += protowire.SizeTag(,6)
		size += protowire.SizeVarint(uint64(x.OptionalInt64))
	}
	if x.OptionalSint64 != 0 {
		size += 1 // size += protowire.SizeTag(,7)
		size += protowire.SizeVarint(protowire.EncodeZigZag(int64(x.OptionalSint64)))
	}
	if x.OptionalUint64 != 0 {
		size += 1 // size += protowire.SizeTag(,8)
		size += protowire.SizeVarint(uint64(x.OptionalUint64))
	}
	if x.OptionalSfixed32 != 0 {
		size += 1 // size += protowire.SizeTag(,9)
		size += 4
	}
	if x.OptionalFixed32 != 0 {
		size += 1 // size += protowire.SizeTag(,10)
		size += 4
	}
	if x.OptionalFloat != 0 {
		size += 1 // size += protowire.SizeTag(,11)
		size += 4
	}
	if x.OptionalSfixed64 != 0 {
		size += 1 // size += protowire.SizeTag(,12)
		size += 8
	}
	if x.OptionalFixed64 != 0 {
		size += 1 // size += protowire.SizeTag(,13)
		size += 8
	}
	if x.OptionalDouble != 0 {
		size += 1 // size += protowire.SizeTag(,14)
		size += 8
	}
	if len(x.OptionalString) > 0 {
		size += 1 // size += protowire.SizeTag(,15)
		size += protowire.SizeBytes(len(x.OptionalString))
	}
	if len(x.OptionalBytes) > 0 {
		size += 2 // size += protowire.SizeTag(,16)
		size += protowire.SizeBytes(len(x.OptionalBytes))
	}
	if x.Optional_Message != nil {
		size += 2 // size += protowire.SizeTag(,17)
		size += protowire.SizeBytes(x.Optional_Message.MarshalSize())
	}
	if x.Optional_Message2 != nil {
		size += 2 // size += protowire.SizeTag(,18)
		size += protowire.SizeBytes(x.Optional_Message2.MarshalSize())
	}
	if len(x.RepeatedBool) > 0 {
		size += 2 // size += protowire.SizeTag(,201)
		size += protowire.SizeBytes(len(x.RepeatedBool))
	}
	if len(x.RepeatedEnum) > 0 {
		size += 2 // size += protowire.SizeTag(,202)
		if len(x.RepeatedEnum) > 0 {
			fsize := 0
			for _, item := range x.RepeatedEnum {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedInt32) > 0 {
		size += 2 // size += protowire.SizeTag(,203)
		if len(x.RepeatedInt32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedInt32 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSint32) > 0 {
		size += 2 // size += protowire.SizeTag(,204)
		if len(x.RepeatedSint32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedSint32 {
				fsize += protowire.SizeVarint(protowire.EncodeZigZag(int64(item)))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedUint32) > 0 {
		size += 2 // size += protowire.SizeTag(,205)
		if len(x.RepeatedUint32) > 0 {
			fsize := 0
			for _, item := range x.RepeatedUint32 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedInt64) > 0 {
		size += 2 // size += protowire.SizeTag(,206)
		if len(x.RepeatedInt64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedInt64 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSint64) > 0 {
		size += 2 // size += protowire.SizeTag(,207)
		if len(x.RepeatedSint64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedSint64 {
				fsize += protowire.SizeVarint(protowire.EncodeZigZag(int64(item)))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedUint64) > 0 {
		size += 2 // size += protowire.SizeTag(,208)
		if len(x.RepeatedUint64) > 0 {
			fsize := 0
			for _, item := range x.RepeatedUint64 {
				fsize += protowire.SizeVarint(uint64(item))
			}
			size += protowire.SizeBytes(fsize)
		}
	}
	if len(x.RepeatedSfixed32) > 0 {
		size += 2 // size += protowire.SizeTag(,209)
		size += protowire.SizeBytes(len(x.RepeatedSfixed32) * 4)
	}
	if len(x.RepeatedFixed32) > 0 {
		size += 2 // size += protowire.SizeTag(,210)
		size += protowire.SizeBytes(len(x.RepeatedFixed32) * 4)
	}
	if len(x.RepeatedFloat) > 0 {
		size += 2 // size += protowire.SizeTag(,211)
		size += protowire.SizeBytes(len(x.RepeatedFloat) * 4)
	}
	if len(x.RepeatedSfixed64) > 0 {
		size += 2 // size += protowire.SizeTag(,212)
		size += protowire.SizeBytes(len(x.RepeatedSfixed64) * 8)
	}
	if len(x.RepeatedFixed64) > 0 {
		size += 2 // size += protowire.SizeTag(,213)
		size += protowire.SizeBytes(len(x.RepeatedFixed64) * 8)
	}
	if len(x.RepeatedDouble) > 0 {
		size += 2 // size += protowire.SizeTag(,214)
		size += protowire.SizeBytes(len(x.RepeatedDouble) * 8)
	}
	if len(x.RepeatedString) > 0 {
		for _, item := range x.RepeatedString {
			size += 2 // size += protowire.SizeTag(,215)
			size += protowire.SizeBytes(len(item))
		}
	}
	if len(x.RepeatedBytes) > 0 {
		for _, item := range x.RepeatedBytes {
			size += 2 // size += protowire.SizeTag(,216)
			size += protowire.SizeBytes(len(item))
		}
	}
	if len(x.Repeated_Message) > 0 {
		for _, item := range x.Repeated_Message {
			size += 2 // size += protowire.SizeTag(,217)
			size += protowire.SizeBytes(item.MarshalSize())
		}
	}
	if len(x.Repeated_Message2) > 0 {
		for _, item := range x.Repeated_Message2 {
			size += 2 // size += protowire.SizeTag(,218)
			size += protowire.SizeBytes(item.MarshalSize())
		}
	}
	if len(x.MapBool) > 0 {
		for mk, mv := range x.MapBool {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,301)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += 1
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapEnum) > 0 {
		for mk, mv := range x.MapEnum {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,302)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt32) > 0 {
		for mk, mv := range x.MapInt32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,303)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapSint32) > 0 {
		for mk, mv := range x.MapSint32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,304)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mv)))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapUint32) > 0 {
		for mk, mv := range x.MapUint32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,305)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt64) > 0 {
		for mk, mv := range x.MapInt64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,306)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapSint64) > 0 {
		for mk, mv := range x.MapSint64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,307)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mv)))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapUint64) > 0 {
		for mk, mv := range x.MapUint64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,308)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapSfixed32) > 0 {
		for mk, mv := range x.MapSfixed32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,309)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 4
			msize += 4
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapFixed32) > 0 {
		for mk, mv := range x.MapFixed32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,310)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 4
			msize += 4
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapFloat) > 0 {
		for mk, mv := range x.MapFloat {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,311)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += 4
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapSfixed64) > 0 {
		for mk, mv := range x.MapSfixed64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,312)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += 8
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapFixed64) > 0 {
		for mk, mv := range x.MapFixed64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,313)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += 8
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapDouble) > 0 {
		for mk, mv := range x.MapDouble {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,314)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += 8
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapString) > 0 {
		for mk, mv := range x.MapString {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,315)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeBytes(len(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapBytes) > 0 {
		for mk, mv := range x.MapBytes {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,316)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeBytes(len(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.Map_Message) > 0 {
		for mk, mv := range x.Map_Message {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,317)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.Map_Message2) > 0 {
		for mk, mv := range x.Map_Message2 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,318)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyInt32) > 0 {
		for mk, mv := range x.MapKeyInt32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,403)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeySint32) > 0 {
		for mk, mv := range x.MapKeySint32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,404)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyUint32) > 0 {
		for mk, mv := range x.MapKeyUint32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,405)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyInt64) > 0 {
		for mk, mv := range x.MapKeyInt64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,406)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeySint64) > 0 {
		for mk, mv := range x.MapKeySint64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,407)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(protowire.EncodeZigZag(int64(mk)))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyUint64) > 0 {
		for mk, mv := range x.MapKeyUint64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,408)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeySfixed32) > 0 {
		for mk, mv := range x.MapKeySfixed32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,409)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 4
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyFixed32) > 0 {
		for mk, mv := range x.MapKeyFixed32 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,410)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 4
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeySfixed64) > 0 {
		for mk, mv := range x.MapKeySfixed64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,412)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 8
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyFixed64) > 0 {
		for mk, mv := range x.MapKeyFixed64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,413)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 8
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapKeyString) > 0 {
		for mk, mv := range x.MapKeyString {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,415)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeBytes(len(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapInt32Int64) > 0 {
		for mk, mv := range x.MapInt32Int64 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,500)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeVarint(uint64(mk))
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapStringMessage) > 0 {
		for mk, mv := range x.MapStringMessage {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,501)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeBytes(len(mk))
			msize += protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapStringMessage2) > 0 {
		for mk, mv := range x.MapStringMessage2 {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,502)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += protowire.SizeBytes(len(mk))
			msize += protowire.SizeBytes(mv.MarshalSize())
			size += protowire.SizeBytes(msize)
		}
	}
	if len(x.MapFixed64Enum) > 0 {
		for mk, mv := range x.MapFixed64Enum {
			_ = mk
			_ = mv
			size += 2      // size += protowire.SizeTag(,503)
			msize := 1 + 1 // size = protowire.SizeTag(1) + protowire.SizeTag(2)
			msize += 8
			msize += protowire.SizeVarint(uint64(mv))
			size += protowire.SizeBytes(msize)
		}
	}
	return
}

func (x *FieldTestMessage) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddBool("OptionalBool", x.OptionalBool)
	enc.AddString("OptionalEnum", x.OptionalEnum.String())
	enc.AddInt32("OptionalInt32", x.OptionalInt32)
	enc.AddInt32("OptionalSint32", x.OptionalSint32)
	enc.AddUint32("OptionalUint32", x.OptionalUint32)
	enc.AddInt64("OptionalInt64", x.OptionalInt64)
	enc.AddInt64("OptionalSint64", x.OptionalSint64)
	enc.AddUint64("OptionalUint64", x.OptionalUint64)
	enc.AddInt32("OptionalSfixed32", x.OptionalSfixed32)
	enc.AddUint32("OptionalFixed32", x.OptionalFixed32)
	enc.AddFloat32("OptionalFloat", x.OptionalFloat)
	enc.AddInt64("OptionalSfixed64", x.OptionalSfixed64)
	enc.AddUint64("OptionalFixed64", x.OptionalFixed64)
	enc.AddFloat64("OptionalDouble", x.OptionalDouble)
	enc.AddString("OptionalString", x.OptionalString)
	enc.AddBinary("OptionalBytes", x.OptionalBytes)
	enc.AddObject("Optional_Message", x.Optional_Message)
	enc.AddObject("Optional_Message2", x.Optional_Message2)
	enc.AddArray("RepeatedBool", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedBool {
			ae.AppendBool(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedEnum", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedEnum {
			ae.AppendString(v.String())
		}
		return nil
	}))
	enc.AddArray("RepeatedInt32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedInt32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSint32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedUint32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedUint32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedInt64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedInt64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSint64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedUint64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedUint64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSfixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSfixed32 {
			ae.AppendInt32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFixed32", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFixed32 {
			ae.AppendUint32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFloat", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFloat {
			ae.AppendFloat32(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedSfixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedSfixed64 {
			ae.AppendInt64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedFixed64", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedFixed64 {
			ae.AppendUint64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedDouble", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedDouble {
			ae.AppendFloat64(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedString", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedString {
			ae.AppendString(v)
		}
		return nil
	}))
	enc.AddArray("RepeatedBytes", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.RepeatedBytes {
			ae.AppendString(base64.StdEncoding.EncodeToString(v))
		}
		return nil
	}))
	enc.AddArray("Repeated_Message", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.Repeated_Message {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddArray("Repeated_Message2", zapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {
		for _, v := range x.Repeated_Message2 {
			ae.AppendObject(v)
		}
		return nil
	}))
	enc.AddObject("MapBool", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapBool {
			enc.AddBool(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapEnum", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapEnum {
			enc.AddString(strconv.FormatInt(int64(k), 10), v.String())
		}
		return nil
	}))
	enc.AddObject("MapInt32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapSint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapSint32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapUint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapUint32 {
			enc.AddUint32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapInt64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt64 {
			enc.AddInt64(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapSint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapSint64 {
			enc.AddInt64(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapUint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapUint64 {
			enc.AddUint64(strconv.FormatUint(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapSfixed32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapSfixed32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapFixed32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapFixed32 {
			enc.AddUint32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapFloat", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapFloat {
			enc.AddFloat32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapSfixed64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapSfixed64 {
			enc.AddInt64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapFixed64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapFixed64 {
			enc.AddUint64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapDouble", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapDouble {
			enc.AddFloat64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapString", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapString {
			enc.AddString(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapBytes", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapBytes {
			enc.AddBinary(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("Map_Message", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.Map_Message {
			enc.AddObject(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("Map_Message2", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.Map_Message2 {
			enc.AddObject(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyInt32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyInt32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeySint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeySint32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyUint32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyUint32 {
			enc.AddInt32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyInt64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyInt64 {
			enc.AddInt32(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeySint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeySint64 {
			enc.AddInt32(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyUint64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyUint64 {
			enc.AddInt32(strconv.FormatUint(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeySfixed32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeySfixed32 {
			enc.AddInt32(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyFixed32", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyFixed32 {
			enc.AddInt32(strconv.FormatUint(uint64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeySfixed64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeySfixed64 {
			enc.AddInt32(strconv.FormatInt(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyFixed64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyFixed64 {
			enc.AddInt32(strconv.FormatUint(k, 10), v)
		}
		return nil
	}))
	enc.AddObject("MapKeyString", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapKeyString {
			enc.AddInt32(k, v)
		}
		return nil
	}))
	enc.AddObject("MapInt32Int64", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapInt32Int64 {
			enc.AddInt64(strconv.FormatInt(int64(k), 10), v)
		}
		return nil
	}))
	enc.AddObject("MapStringMessage", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapStringMessage {
			enc.AddObject(k, v)
		}
		return nil
	}))
	enc.AddObject("MapStringMessage2", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapStringMessage2 {
			enc.AddObject(k, v)
		}
		return nil
	}))
	enc.AddObject("MapFixed64Enum", zapcore.ObjectMarshalerFunc(func(oe zapcore.ObjectEncoder) error {
		for k, v := range x.MapFixed64Enum {
			enc.AddString(strconv.FormatUint(k, 10), v.String())
		}
		return nil
	}))
	return nil
}

type ZapArrayFieldTestMessage []*FieldTestMessage

func (x ZapArrayFieldTestMessage) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}
func LogArrayFieldTestMessage(name string, v []*FieldTestMessage) zap.Field {
	return zap.Array(name, ZapArrayFieldTestMessage(v))
}

type FieldTestMessage_Enum int32

const (
	FieldTestMessage_ZERO FieldTestMessage_Enum = 0
	FieldTestMessage_ONE  FieldTestMessage_Enum = 1
	FieldTestMessage_TWO  FieldTestMessage_Enum = 2
)

// Enum value maps for FieldTestMessage_Enum.
var (
	FieldTestMessage_Enum_name = map[int32]string{
		0: "ZERO",
		1: "ONE",
		2: "TWO",
	}
	FieldTestMessage_Enum_value = map[string]int32{
		"ZERO": 0,
		"ONE":  1,
		"TWO":  2,
	}
)

func (x FieldTestMessage_Enum) Enum() *FieldTestMessage_Enum {
	p := new(FieldTestMessage_Enum)
	*p = x
	return p
}

func (x FieldTestMessage_Enum) String() string {
	if name, ok := FieldTestMessage_Enum_name[int32(x)]; ok {
		return name
	}
	return strconv.FormatInt(int64(x), 10)
}

type FieldTestMessage_Message struct {
}

func (x *FieldTestMessage_Message) Reset() {
	*x = FieldTestMessage_Message{}
}

// MarshalObjectTo marshal data to []byte
func (x *FieldTestMessage_Message) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	return
}

// MarshalObject marshal data to []byte
func (x *FieldTestMessage_Message) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// UnmarshalObject unmarshal data from []byte
func (x *FieldTestMessage_Message) UnmarshalObject(data []byte) (err error) {
	return
}

// MarshalSize calc marshal data need space
func (x *FieldTestMessage_Message) MarshalSize() (size int) {
	return
}

func (x *FieldTestMessage_Message) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return nil
}

type ZapArrayFieldTestMessage_Message []*FieldTestMessage_Message

func (x ZapArrayFieldTestMessage_Message) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}
func LogArrayFieldTestMessage_Message(name string, v []*FieldTestMessage_Message) zap.Field {
	return zap.Array(name, ZapArrayFieldTestMessage_Message(v))
}

type FieldTestMessage_Message2 struct {
	Bool bool                  `json:"bool,omitempty" db:"bool"`
	Enum FieldTestMessage_Enum `json:"enum,omitempty" db:"enum"`
}

func (x *FieldTestMessage_Message2) Reset() {
	*x = FieldTestMessage_Message2{}
}

// MarshalObjectTo marshal data to []byte
func (x *FieldTestMessage_Message2) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Bool {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, protowire.EncodeBool(x.Bool))
	}
	if x.Enum != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Enum))
	}
	return
}

// MarshalObject marshal data to []byte
func (x *FieldTestMessage_Message2) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// UnmarshalObject unmarshal data from []byte
func (x *FieldTestMessage_Message2) UnmarshalObject(data []byte) (err error) {
	index := 0
	ignoreGroup := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		// ignore group
		if ignoreGroup > 0 {
			switch typ {
			case protowire.VarintType:
				_, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = protowire.ParseError(cnt)
					return
				}
				index += cnt
			case protowire.Fixed32Type:
				index += 4
			case protowire.Fixed64Type:
				index += 8
			case protowire.BytesType:
				v, cnt := protowire.ConsumeBytes(data[index:])
				if v == nil {
					if cnt < 0 {
						err = protowire.ParseError(cnt)
					} else {
						err = errors.New("invalid data")
					}
					return
				}
				index += cnt
			case protowire.StartGroupType:
				ignoreGroup++
			case protowire.EndGroupType:
				ignoreGroup--
			}
			continue
		}
		switch num {
		case 1:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage_Message2.Bool id:1. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage_Message2.Bool id:1. invalid varint value")
				return
			}
			index += cnt
			x.Bool = protowire.DecodeBool(v)
		case 2:
			if typ != protowire.VarintType {
				err = errors.New("invlaid field FieldTestMessage_Message2.Enum id:2. not varint type")
				return
			}
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("invlaid field FieldTestMessage_Message2.Enum id:2. invalid varint value")
				return
			}
			index += cnt
			x.Enum = FieldTestMessage_Enum(v)
		default: // skip fields
			switch typ {
			case protowire.VarintType:
				_, cnt := protowire.ConsumeVarint(data[index:])
				if cnt < 1 {
					err = protowire.ParseError(cnt)
					return
				}
				index += cnt
			case protowire.Fixed32Type:
				index += 4
			case protowire.Fixed64Type:
				index += 8
			case protowire.BytesType:
				v, cnt := protowire.ConsumeBytes(data[index:])
				if v == nil {
					if cnt < 0 {
						err = protowire.ParseError(cnt)
					} else {
						err = errors.New("invalid data")
					}
					return
				}
				index += cnt
			case protowire.StartGroupType:
				ignoreGroup++
			case protowire.EndGroupType:
				ignoreGroup--
			}
		}
	}

	return
}

// MarshalSize calc marshal data need space
func (x *FieldTestMessage_Message2) MarshalSize() (size int) {
	if x.Bool {
		size += 1 // size += protowire.SizeTag(,1)
		size += 1
	}
	if x.Enum != 0 {
		size += 1 // size += protowire.SizeTag(,2)
		size += protowire.SizeVarint(uint64(x.Enum))
	}
	return
}

func (x *FieldTestMessage_Message2) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddBool("Bool", x.Bool)
	enc.AddString("Enum", x.Enum.String())
	return nil
}

type ZapArrayFieldTestMessage_Message2 []*FieldTestMessage_Message2

func (x ZapArrayFieldTestMessage_Message2) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}
func LogArrayFieldTestMessage_Message2(name string, v []*FieldTestMessage_Message2) zap.Field {
	return zap.Array(name, ZapArrayFieldTestMessage_Message2(v))
}
