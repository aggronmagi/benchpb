// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fields.proto

package proto3

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Enum int32

const (
	Enum_ZERO Enum = 0
	Enum_ONE  Enum = 1
	Enum_TWO  Enum = 2
)

var Enum_name = map[int32]string{
	0: "ZERO",
	1: "ONE",
	2: "TWO",
}

var Enum_value = map[string]int32{
	"ZERO": 0,
	"ONE":  1,
	"TWO":  2,
}

func (x Enum) String() string {
	return proto.EnumName(Enum_name, int32(x))
}

func (Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0}
}

type FieldTestMessage_Enum int32

const (
	FieldTestMessage_ZERO FieldTestMessage_Enum = 0
	FieldTestMessage_ONE  FieldTestMessage_Enum = 1
	FieldTestMessage_TWO  FieldTestMessage_Enum = 2
)

var FieldTestMessage_Enum_name = map[int32]string{
	0: "ZERO",
	1: "ONE",
	2: "TWO",
}

var FieldTestMessage_Enum_value = map[string]int32{
	"ZERO": 0,
	"ONE":  1,
	"TWO":  2,
}

func (x FieldTestMessage_Enum) String() string {
	return proto.EnumName(FieldTestMessage_Enum_name, int32(x))
}

func (FieldTestMessage_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 0}
}

type FieldTestMessage struct {
	OptionalBool     bool                            `protobuf:"varint,1,opt,name=optional_bool,json=optionalBool,proto3" json:"optional_bool,omitempty"`
	OptionalEnum     FieldTestMessage_Enum           `protobuf:"varint,2,opt,name=optional_enum,json=optionalEnum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"optional_enum,omitempty"`
	OptionalInt32    int32                           `protobuf:"varint,3,opt,name=optional_int32,json=optionalInt32,proto3" json:"optional_int32,omitempty"`
	OptionalSint32   int32                           `protobuf:"zigzag32,4,opt,name=optional_sint32,json=optionalSint32,proto3" json:"optional_sint32,omitempty"`
	OptionalUint32   uint32                          `protobuf:"varint,5,opt,name=optional_uint32,json=optionalUint32,proto3" json:"optional_uint32,omitempty"`
	OptionalInt64    int64                           `protobuf:"varint,6,opt,name=optional_int64,json=optionalInt64,proto3" json:"optional_int64,omitempty"`
	OptionalSint64   int64                           `protobuf:"zigzag64,7,opt,name=optional_sint64,json=optionalSint64,proto3" json:"optional_sint64,omitempty"`
	OptionalUint64   uint64                          `protobuf:"varint,8,opt,name=optional_uint64,json=optionalUint64,proto3" json:"optional_uint64,omitempty"`
	OptionalSfixed32 int32                           `protobuf:"fixed32,9,opt,name=optional_sfixed32,json=optionalSfixed32,proto3" json:"optional_sfixed32,omitempty"`
	OptionalFixed32  uint32                          `protobuf:"fixed32,10,opt,name=optional_fixed32,json=optionalFixed32,proto3" json:"optional_fixed32,omitempty"`
	OptionalFloat    float32                         `protobuf:"fixed32,11,opt,name=optional_float,json=optionalFloat,proto3" json:"optional_float,omitempty"`
	OptionalSfixed64 int64                           `protobuf:"fixed64,12,opt,name=optional_sfixed64,json=optionalSfixed64,proto3" json:"optional_sfixed64,omitempty"`
	OptionalFixed64  uint64                          `protobuf:"fixed64,13,opt,name=optional_fixed64,json=optionalFixed64,proto3" json:"optional_fixed64,omitempty"`
	OptionalDouble   float64                         `protobuf:"fixed64,14,opt,name=optional_double,json=optionalDouble,proto3" json:"optional_double,omitempty"`
	OptionalString   string                          `protobuf:"bytes,15,opt,name=optional_string,json=optionalString,proto3" json:"optional_string,omitempty"`
	OptionalBytes    []byte                          `protobuf:"bytes,16,opt,name=optional_bytes,json=optionalBytes,proto3" json:"optional_bytes,omitempty"`
	OptionalMessage  *FieldTestMessage_Message       `protobuf:"bytes,17,opt,name=optional_message,json=optionalMessage,proto3" json:"optional_message,omitempty"`
	OptionalMessage2 *FieldTestMessage_Message2      `protobuf:"bytes,18,opt,name=optional_message2,json=optionalMessage2,proto3" json:"optional_message2,omitempty"`
	RepeatedBool     []bool                          `protobuf:"varint,201,rep,packed,name=repeated_bool,json=repeatedBool,proto3" json:"repeated_bool,omitempty"`
	RepeatedEnum     []FieldTestMessage_Enum         `protobuf:"varint,202,rep,packed,name=repeated_enum,json=repeatedEnum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"repeated_enum,omitempty"`
	RepeatedInt32    []int32                         `protobuf:"varint,203,rep,packed,name=repeated_int32,json=repeatedInt32,proto3" json:"repeated_int32,omitempty"`
	RepeatedSint32   []int32                         `protobuf:"zigzag32,204,rep,packed,name=repeated_sint32,json=repeatedSint32,proto3" json:"repeated_sint32,omitempty"`
	RepeatedUint32   []uint32                        `protobuf:"varint,205,rep,packed,name=repeated_uint32,json=repeatedUint32,proto3" json:"repeated_uint32,omitempty"`
	RepeatedInt64    []int64                         `protobuf:"varint,206,rep,packed,name=repeated_int64,json=repeatedInt64,proto3" json:"repeated_int64,omitempty"`
	RepeatedSint64   []int64                         `protobuf:"zigzag64,207,rep,packed,name=repeated_sint64,json=repeatedSint64,proto3" json:"repeated_sint64,omitempty"`
	RepeatedUint64   []uint64                        `protobuf:"varint,208,rep,packed,name=repeated_uint64,json=repeatedUint64,proto3" json:"repeated_uint64,omitempty"`
	RepeatedSfixed32 []int32                         `protobuf:"fixed32,209,rep,packed,name=repeated_sfixed32,json=repeatedSfixed32,proto3" json:"repeated_sfixed32,omitempty"`
	RepeatedFixed32  []uint32                        `protobuf:"fixed32,210,rep,packed,name=repeated_fixed32,json=repeatedFixed32,proto3" json:"repeated_fixed32,omitempty"`
	RepeatedFloat    []float32                       `protobuf:"fixed32,211,rep,packed,name=repeated_float,json=repeatedFloat,proto3" json:"repeated_float,omitempty"`
	RepeatedSfixed64 []int64                         `protobuf:"fixed64,212,rep,packed,name=repeated_sfixed64,json=repeatedSfixed64,proto3" json:"repeated_sfixed64,omitempty"`
	RepeatedFixed64  []uint64                        `protobuf:"fixed64,213,rep,packed,name=repeated_fixed64,json=repeatedFixed64,proto3" json:"repeated_fixed64,omitempty"`
	RepeatedDouble   []float64                       `protobuf:"fixed64,214,rep,packed,name=repeated_double,json=repeatedDouble,proto3" json:"repeated_double,omitempty"`
	RepeatedString   []string                        `protobuf:"bytes,215,rep,name=repeated_string,json=repeatedString,proto3" json:"repeated_string,omitempty"`
	RepeatedBytes    [][]byte                        `protobuf:"bytes,216,rep,name=repeated_bytes,json=repeatedBytes,proto3" json:"repeated_bytes,omitempty"`
	RepeatedMessage  []*FieldTestMessage_Message     `protobuf:"bytes,217,rep,name=repeated_message,json=repeatedMessage,proto3" json:"repeated_message,omitempty"`
	RepeatedMessage2 []*FieldTestMessage_Message2    `protobuf:"bytes,218,rep,name=repeated_message2,json=repeatedMessage2,proto3" json:"repeated_message2,omitempty"`
	NopackBool       []bool                          `protobuf:"varint,31,rep,name=nopack_bool,json=nopackBool,proto3" json:"nopack_bool,omitempty"`
	NopackEnum       []FieldTestMessage_Enum         `protobuf:"varint,32,rep,name=nopack_enum,json=nopackEnum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"nopack_enum,omitempty"`
	NopackInt32      []int32                         `protobuf:"varint,33,rep,name=nopack_int32,json=nopackInt32,proto3" json:"nopack_int32,omitempty"`
	NopackSint32     []int32                         `protobuf:"zigzag32,34,rep,name=nopack_sint32,json=nopackSint32,proto3" json:"nopack_sint32,omitempty"`
	NopackUint32     []uint32                        `protobuf:"varint,35,rep,name=nopack_uint32,json=nopackUint32,proto3" json:"nopack_uint32,omitempty"`
	NopackInt64      []int64                         `protobuf:"varint,36,rep,name=nopack_int64,json=nopackInt64,proto3" json:"nopack_int64,omitempty"`
	NopackSint64     []int64                         `protobuf:"zigzag64,37,rep,name=nopack_sint64,json=nopackSint64,proto3" json:"nopack_sint64,omitempty"`
	NopackUint64     []uint64                        `protobuf:"varint,38,rep,name=nopack_uint64,json=nopackUint64,proto3" json:"nopack_uint64,omitempty"`
	NopackSfixed32   []int32                         `protobuf:"fixed32,39,rep,name=nopack_sfixed32,json=nopackSfixed32,proto3" json:"nopack_sfixed32,omitempty"`
	NopackFixed32    []uint32                        `protobuf:"fixed32,40,rep,name=nopack_fixed32,json=nopackFixed32,proto3" json:"nopack_fixed32,omitempty"`
	NopackFloat      []float32                       `protobuf:"fixed32,41,rep,name=nopack_float,json=nopackFloat,proto3" json:"nopack_float,omitempty"`
	NopackSfixed64   []int64                         `protobuf:"fixed64,42,rep,name=nopack_sfixed64,json=nopackSfixed64,proto3" json:"nopack_sfixed64,omitempty"`
	NopackFixed64    []uint64                        `protobuf:"fixed64,43,rep,name=nopack_fixed64,json=nopackFixed64,proto3" json:"nopack_fixed64,omitempty"`
	NopackDouble     []float64                       `protobuf:"fixed64,44,rep,name=nopack_double,json=nopackDouble,proto3" json:"nopack_double,omitempty"`
	NopackString     []string                        `protobuf:"bytes,45,rep,name=nopack_string,json=nopackString,proto3" json:"nopack_string,omitempty"`
	NopackBytes      [][]byte                        `protobuf:"bytes,46,rep,name=nopack_bytes,json=nopackBytes,proto3" json:"nopack_bytes,omitempty"`
	NopackMessage    []*FieldTestMessage_Message     `protobuf:"bytes,47,rep,name=nopack_message,json=nopackMessage,proto3" json:"nopack_message,omitempty"`
	NopackMessage2   []*FieldTestMessage_Message2    `protobuf:"bytes,48,rep,name=nopack_message2,json=nopackMessage2,proto3" json:"nopack_message2,omitempty"`
	MapBool          map[int32]bool                  `protobuf:"bytes,51,rep,name=map_bool,json=mapBool,proto3" json:"map_bool,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapEnum          map[int32]FieldTestMessage_Enum `protobuf:"bytes,52,rep,name=map_enum,json=mapEnum,proto3" json:"map_enum,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum"`
	MapInt32         map[int32]int32                 `protobuf:"bytes,53,rep,name=map_int32,json=mapInt32,proto3" json:"map_int32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map<sint32, sint32> map_sint32 = 54;
	MapUint32 map[uint32]uint32 `protobuf:"bytes,55,rep,name=map_uint32,json=mapUint32,proto3" json:"map_uint32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapInt64  map[int64]int64   `protobuf:"bytes,56,rep,name=map_int64,json=mapInt64,proto3" json:"map_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map<sint64, sint64> map_sint64 = 57;
	MapUint64 map[uint64]uint64 `protobuf:"bytes,58,rep,name=map_uint64,json=mapUint64,proto3" json:"map_uint64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map<sfixed32, sfixed32> map_sfixed32 = 59;
	// map<fixed32, fixed32> map_fixed32 = 60;
	MapFloat map[int32]float32 `protobuf:"bytes,61,rep,name=map_float,json=mapFloat,proto3" json:"map_float,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	// map<int32, sfixed64> map_sfixed64 = 62;
	// map<int32, fixed64> map_fixed64 = 63;
	MapDouble   map[int32]float64                    `protobuf:"bytes,64,rep,name=map_double,json=mapDouble,proto3" json:"map_double,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	MapString   map[int32]string                     `protobuf:"bytes,65,rep,name=map_string,json=mapString,proto3" json:"map_string,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapBytes    map[int32][]byte                     `protobuf:"bytes,66,rep,name=map_bytes,json=mapBytes,proto3" json:"map_bytes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapMessage  map[int32]*FieldTestMessage_Message  `protobuf:"bytes,67,rep,name=map_message,json=mapMessage,proto3" json:"map_message,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapMessage2 map[int32]*FieldTestMessage_Message2 `protobuf:"bytes,68,rep,name=map_message2,json=mapMessage2,proto3" json:"map_message2,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//	map<bool,int32> map_key_bool = 401;
	//
	// map<Enum,int32> map_key_enum = 402;
	MapKeyInt32 map[int32]int32 `protobuf:"bytes,73,rep,name=map_key_int32,json=mapKeyInt32,proto3" json:"map_key_int32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// /map<sint32,int32> map_key_sint32 = 404;
	MapKeyUint32 map[uint32]int32 `protobuf:"bytes,75,rep,name=map_key_uint32,json=mapKeyUint32,proto3" json:"map_key_uint32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyInt64  map[int64]int32  `protobuf:"bytes,76,rep,name=map_key_int64,json=mapKeyInt64,proto3" json:"map_key_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// /map<sint64,int32> map_key_sint64 = 407;
	MapKeyUint64 map[uint64]int32 `protobuf:"bytes,78,rep,name=map_key_uint64,json=mapKeyUint64,proto3" json:"map_key_uint64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// /map<sfixed32,int32> map_key_sfixed32 = 409;
	// /map<fixed32,int32> map_key_fixed32 = 410;
	// map<float,int32> map_key_float = 411;
	// /map<sfixed64,int32> map_key_sfixed64 = 412;
	// /map<fixed64,int32> map_key_fixed64 = 413;
	// map<double,int32> map_key_double = 414;
	MapKeyString         map[string]int32                      `protobuf:"bytes,85,rep,name=map_key_string,json=mapKeyString,proto3" json:"map_key_string,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapInt32Int64        map[int32]int64                       `protobuf:"bytes,90,rep,name=map_int32_int64,json=mapInt32Int64,proto3" json:"map_int32_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapStringMessage     map[string]*FieldTestMessage_Message  `protobuf:"bytes,91,rep,name=map_string_message,json=mapStringMessage,proto3" json:"map_string_message,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapStringMessage2    map[string]*FieldTestMessage_Message2 `protobuf:"bytes,92,rep,name=map_string_message2,json=mapStringMessage2,proto3" json:"map_string_message2,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *FieldTestMessage) Reset()         { *m = FieldTestMessage{} }
func (m *FieldTestMessage) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage) ProtoMessage()    {}
func (*FieldTestMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0}
}
func (m *FieldTestMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage.Merge(m, src)
}
func (m *FieldTestMessage) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage proto.InternalMessageInfo

func (m *FieldTestMessage) GetOptionalBool() bool {
	if m != nil {
		return m.OptionalBool
	}
	return false
}

func (m *FieldTestMessage) GetOptionalEnum() FieldTestMessage_Enum {
	if m != nil {
		return m.OptionalEnum
	}
	return FieldTestMessage_ZERO
}

func (m *FieldTestMessage) GetOptionalInt32() int32 {
	if m != nil {
		return m.OptionalInt32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSint32() int32 {
	if m != nil {
		return m.OptionalSint32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalUint32() uint32 {
	if m != nil {
		return m.OptionalUint32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalInt64() int64 {
	if m != nil {
		return m.OptionalInt64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSint64() int64 {
	if m != nil {
		return m.OptionalSint64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalUint64() uint64 {
	if m != nil {
		return m.OptionalUint64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSfixed32() int32 {
	if m != nil {
		return m.OptionalSfixed32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFixed32() uint32 {
	if m != nil {
		return m.OptionalFixed32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFloat() float32 {
	if m != nil {
		return m.OptionalFloat
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSfixed64() int64 {
	if m != nil {
		return m.OptionalSfixed64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFixed64() uint64 {
	if m != nil {
		return m.OptionalFixed64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalDouble() float64 {
	if m != nil {
		return m.OptionalDouble
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalString() string {
	if m != nil {
		return m.OptionalString
	}
	return ""
}

func (m *FieldTestMessage) GetOptionalBytes() []byte {
	if m != nil {
		return m.OptionalBytes
	}
	return nil
}

func (m *FieldTestMessage) GetOptionalMessage() *FieldTestMessage_Message {
	if m != nil {
		return m.OptionalMessage
	}
	return nil
}

func (m *FieldTestMessage) GetOptionalMessage2() *FieldTestMessage_Message2 {
	if m != nil {
		return m.OptionalMessage2
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedBool() []bool {
	if m != nil {
		return m.RepeatedBool
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedEnum() []FieldTestMessage_Enum {
	if m != nil {
		return m.RepeatedEnum
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedInt32() []int32 {
	if m != nil {
		return m.RepeatedInt32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSint32() []int32 {
	if m != nil {
		return m.RepeatedSint32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedUint32() []uint32 {
	if m != nil {
		return m.RepeatedUint32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedInt64() []int64 {
	if m != nil {
		return m.RepeatedInt64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSint64() []int64 {
	if m != nil {
		return m.RepeatedSint64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedUint64() []uint64 {
	if m != nil {
		return m.RepeatedUint64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSfixed32() []int32 {
	if m != nil {
		return m.RepeatedSfixed32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFixed32() []uint32 {
	if m != nil {
		return m.RepeatedFixed32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFloat() []float32 {
	if m != nil {
		return m.RepeatedFloat
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSfixed64() []int64 {
	if m != nil {
		return m.RepeatedSfixed64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFixed64() []uint64 {
	if m != nil {
		return m.RepeatedFixed64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedDouble() []float64 {
	if m != nil {
		return m.RepeatedDouble
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedString() []string {
	if m != nil {
		return m.RepeatedString
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedBytes() [][]byte {
	if m != nil {
		return m.RepeatedBytes
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedMessage() []*FieldTestMessage_Message {
	if m != nil {
		return m.RepeatedMessage
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedMessage2() []*FieldTestMessage_Message2 {
	if m != nil {
		return m.RepeatedMessage2
	}
	return nil
}

func (m *FieldTestMessage) GetNopackBool() []bool {
	if m != nil {
		return m.NopackBool
	}
	return nil
}

func (m *FieldTestMessage) GetNopackEnum() []FieldTestMessage_Enum {
	if m != nil {
		return m.NopackEnum
	}
	return nil
}

func (m *FieldTestMessage) GetNopackInt32() []int32 {
	if m != nil {
		return m.NopackInt32
	}
	return nil
}

func (m *FieldTestMessage) GetNopackSint32() []int32 {
	if m != nil {
		return m.NopackSint32
	}
	return nil
}

func (m *FieldTestMessage) GetNopackUint32() []uint32 {
	if m != nil {
		return m.NopackUint32
	}
	return nil
}

func (m *FieldTestMessage) GetNopackInt64() []int64 {
	if m != nil {
		return m.NopackInt64
	}
	return nil
}

func (m *FieldTestMessage) GetNopackSint64() []int64 {
	if m != nil {
		return m.NopackSint64
	}
	return nil
}

func (m *FieldTestMessage) GetNopackUint64() []uint64 {
	if m != nil {
		return m.NopackUint64
	}
	return nil
}

func (m *FieldTestMessage) GetNopackSfixed32() []int32 {
	if m != nil {
		return m.NopackSfixed32
	}
	return nil
}

func (m *FieldTestMessage) GetNopackFixed32() []uint32 {
	if m != nil {
		return m.NopackFixed32
	}
	return nil
}

func (m *FieldTestMessage) GetNopackFloat() []float32 {
	if m != nil {
		return m.NopackFloat
	}
	return nil
}

func (m *FieldTestMessage) GetNopackSfixed64() []int64 {
	if m != nil {
		return m.NopackSfixed64
	}
	return nil
}

func (m *FieldTestMessage) GetNopackFixed64() []uint64 {
	if m != nil {
		return m.NopackFixed64
	}
	return nil
}

func (m *FieldTestMessage) GetNopackDouble() []float64 {
	if m != nil {
		return m.NopackDouble
	}
	return nil
}

func (m *FieldTestMessage) GetNopackString() []string {
	if m != nil {
		return m.NopackString
	}
	return nil
}

func (m *FieldTestMessage) GetNopackBytes() [][]byte {
	if m != nil {
		return m.NopackBytes
	}
	return nil
}

func (m *FieldTestMessage) GetNopackMessage() []*FieldTestMessage_Message {
	if m != nil {
		return m.NopackMessage
	}
	return nil
}

func (m *FieldTestMessage) GetNopackMessage2() []*FieldTestMessage_Message2 {
	if m != nil {
		return m.NopackMessage2
	}
	return nil
}

func (m *FieldTestMessage) GetMapBool() map[int32]bool {
	if m != nil {
		return m.MapBool
	}
	return nil
}

func (m *FieldTestMessage) GetMapEnum() map[int32]FieldTestMessage_Enum {
	if m != nil {
		return m.MapEnum
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt32() map[int32]int32 {
	if m != nil {
		return m.MapInt32
	}
	return nil
}

func (m *FieldTestMessage) GetMapUint32() map[uint32]uint32 {
	if m != nil {
		return m.MapUint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt64() map[int64]int64 {
	if m != nil {
		return m.MapInt64
	}
	return nil
}

func (m *FieldTestMessage) GetMapUint64() map[uint64]uint64 {
	if m != nil {
		return m.MapUint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapFloat() map[int32]float32 {
	if m != nil {
		return m.MapFloat
	}
	return nil
}

func (m *FieldTestMessage) GetMapDouble() map[int32]float64 {
	if m != nil {
		return m.MapDouble
	}
	return nil
}

func (m *FieldTestMessage) GetMapString() map[int32]string {
	if m != nil {
		return m.MapString
	}
	return nil
}

func (m *FieldTestMessage) GetMapBytes() map[int32][]byte {
	if m != nil {
		return m.MapBytes
	}
	return nil
}

func (m *FieldTestMessage) GetMapMessage() map[int32]*FieldTestMessage_Message {
	if m != nil {
		return m.MapMessage
	}
	return nil
}

func (m *FieldTestMessage) GetMapMessage2() map[int32]*FieldTestMessage_Message2 {
	if m != nil {
		return m.MapMessage2
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyInt32() map[int32]int32 {
	if m != nil {
		return m.MapKeyInt32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyUint32() map[uint32]int32 {
	if m != nil {
		return m.MapKeyUint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyInt64() map[int64]int32 {
	if m != nil {
		return m.MapKeyInt64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyUint64() map[uint64]int32 {
	if m != nil {
		return m.MapKeyUint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyString() map[string]int32 {
	if m != nil {
		return m.MapKeyString
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt32Int64() map[int32]int64 {
	if m != nil {
		return m.MapInt32Int64
	}
	return nil
}

func (m *FieldTestMessage) GetMapStringMessage() map[string]*FieldTestMessage_Message {
	if m != nil {
		return m.MapStringMessage
	}
	return nil
}

func (m *FieldTestMessage) GetMapStringMessage2() map[string]*FieldTestMessage_Message2 {
	if m != nil {
		return m.MapStringMessage2
	}
	return nil
}

type FieldTestMessage_Message struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FieldTestMessage_Message) Reset()         { *m = FieldTestMessage_Message{} }
func (m *FieldTestMessage_Message) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage_Message) ProtoMessage()    {}
func (*FieldTestMessage_Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 20}
}
func (m *FieldTestMessage_Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage_Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage_Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage_Message.Merge(m, src)
}
func (m *FieldTestMessage_Message) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage_Message) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage_Message.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage_Message proto.InternalMessageInfo

type FieldTestMessage_Message2 struct {
	Bv                   bool                  `protobuf:"varint,1,opt,name=bv,proto3" json:"bv,omitempty"`
	Ev                   FieldTestMessage_Enum `protobuf:"varint,2,opt,name=ev,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"ev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *FieldTestMessage_Message2) Reset()         { *m = FieldTestMessage_Message2{} }
func (m *FieldTestMessage_Message2) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage_Message2) ProtoMessage()    {}
func (*FieldTestMessage_Message2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 21}
}
func (m *FieldTestMessage_Message2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage_Message2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage_Message2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage_Message2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage_Message2.Merge(m, src)
}
func (m *FieldTestMessage_Message2) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage_Message2) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage_Message2.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage_Message2 proto.InternalMessageInfo

func (m *FieldTestMessage_Message2) GetBv() bool {
	if m != nil {
		return m.Bv
	}
	return false
}

func (m *FieldTestMessage_Message2) GetEv() FieldTestMessage_Enum {
	if m != nil {
		return m.Ev
	}
	return FieldTestMessage_ZERO
}

type Example struct {
	Filed                int32    `protobuf:"varint,1,opt,name=filed,proto3" json:"filed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Example) Reset()         { *m = Example{} }
func (m *Example) String() string { return proto.CompactTextString(m) }
func (*Example) ProtoMessage()    {}
func (*Example) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{1}
}
func (m *Example) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Example) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Example.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Example) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Example.Merge(m, src)
}
func (m *Example) XXX_Size() int {
	return m.Size()
}
func (m *Example) XXX_DiscardUnknown() {
	xxx_messageInfo_Example.DiscardUnknown(m)
}

var xxx_messageInfo_Example proto.InternalMessageInfo

func (m *Example) GetFiled() int32 {
	if m != nil {
		return m.Filed
	}
	return 0
}

func init() {
	proto.RegisterEnum("goproto.protoc.proto3.Enum", Enum_name, Enum_value)
	proto.RegisterEnum("goproto.protoc.proto3.FieldTestMessage_Enum", FieldTestMessage_Enum_name, FieldTestMessage_Enum_value)
	proto.RegisterType((*FieldTestMessage)(nil), "goproto.protoc.proto3.FieldTestMessage")
	proto.RegisterMapType((map[int32]bool)(nil), "goproto.protoc.proto3.FieldTestMessage.MapBoolEntry")
	proto.RegisterMapType((map[int32][]byte)(nil), "goproto.protoc.proto3.FieldTestMessage.MapBytesEntry")
	proto.RegisterMapType((map[int32]float64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapDoubleEntry")
	proto.RegisterMapType((map[int32]FieldTestMessage_Enum)(nil), "goproto.protoc.proto3.FieldTestMessage.MapEnumEntry")
	proto.RegisterMapType((map[int32]float32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapFloatEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt32Entry")
	proto.RegisterMapType((map[int32]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt32Int64Entry")
	proto.RegisterMapType((map[int64]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt64Entry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyInt32Entry")
	proto.RegisterMapType((map[int64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyInt64Entry")
	proto.RegisterMapType((map[string]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyStringEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyUint32Entry")
	proto.RegisterMapType((map[uint64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyUint64Entry")
	proto.RegisterMapType((map[int32]*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.MapMessage2Entry")
	proto.RegisterMapType((map[int32]*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.MapMessageEntry")
	proto.RegisterMapType((map[int32]string)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringEntry")
	proto.RegisterMapType((map[string]*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringMessage2Entry")
	proto.RegisterMapType((map[string]*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringMessageEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapUint32Entry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapUint64Entry")
	proto.RegisterType((*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.Message")
	proto.RegisterType((*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.Message2")
	proto.RegisterType((*Example)(nil), "goproto.protoc.proto3.Example")
}

func init() { proto.RegisterFile("fields.proto", fileDescriptor_d39ad626ec0e575e) }

var fileDescriptor_d39ad626ec0e575e = []byte{
	// 1528 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x98, 0x6b, 0x73, 0x13, 0xb7,
	0x17, 0xc6, 0x23, 0x5f, 0x62, 0x5b, 0xf1, 0x75, 0xff, 0x7f, 0x18, 0x0d, 0x2f, 0x60, 0x1b, 0x0a,
	0x2c, 0x97, 0x9a, 0x8c, 0x23, 0x04, 0x4d, 0x81, 0xd2, 0x94, 0x64, 0x86, 0xa1, 0x25, 0xd3, 0x2d,
	0xb4, 0x4c, 0xa0, 0x65, 0x6c, 0xb2, 0xa1, 0x9e, 0xf8, 0x36, 0x89, 0x93, 0x21, 0xdf, 0xb0, 0xf7,
	0xd2, 0xfb, 0xe5, 0x55, 0x87, 0x4f, 0xd2, 0x91, 0x74, 0xa4, 0x95, 0x76, 0x37, 0xe3, 0xec, 0x0e,
	0xaf, 0x6c, 0x8b, 0x73, 0x9e, 0xe7, 0x91, 0xa2, 0xdf, 0x1e, 0x6c, 0x5c, 0xdd, 0xee, 0x07, 0x83,
	0xad, 0xbd, 0xf6, 0x64, 0x77, 0x3c, 0x1d, 0x3b, 0x27, 0x5e, 0x8c, 0xc5, 0x1b, 0xf9, 0xf1, 0xb9,
	0x7c, 0x59, 0x5e, 0x7c, 0xb5, 0x84, 0x9b, 0xeb, 0xbc, 0xee, 0x61, 0xb0, 0x37, 0xfd, 0x38, 0xd8,
	0xdb, 0xeb, 0xbe, 0x08, 0x9c, 0xb3, 0xb8, 0x36, 0x9e, 0x4c, 0xfb, 0xe3, 0x51, 0x77, 0xf0, 0xac,
	0x37, 0x1e, 0x0f, 0x08, 0x72, 0x91, 0x57, 0xf6, 0xab, 0x6a, 0x71, 0x75, 0x3c, 0x1e, 0x38, 0x9f,
	0x18, 0x45, 0xc1, 0x68, 0x7f, 0x48, 0x72, 0x2e, 0xf2, 0xea, 0x9d, 0x2b, 0xed, 0x44, 0xa3, 0x76,
	0xd4, 0xa4, 0xbd, 0x36, 0xda, 0x1f, 0x86, 0x92, 0xfc, 0x93, 0x73, 0x0e, 0xd7, 0xb5, 0x64, 0x7f,
	0x34, 0x5d, 0xee, 0x90, 0xbc, 0x8b, 0xbc, 0xa2, 0xaf, 0x8d, 0xee, 0xf1, 0x45, 0xe7, 0x02, 0x6e,
	0xe8, 0xb2, 0x3d, 0x59, 0x57, 0x70, 0x91, 0xd7, 0xf2, 0x75, 0xf7, 0xa7, 0xfd, 0x58, 0xe1, 0xbe,
	0x2c, 0x2c, 0xba, 0xc8, 0xab, 0x85, 0x85, 0x8f, 0x64, 0x61, 0xc4, 0x98, 0x51, 0x32, 0xef, 0x22,
	0x2f, 0x6f, 0x19, 0x33, 0x1a, 0x33, 0x66, 0x94, 0x94, 0x5c, 0xe4, 0x39, 0xb6, 0x71, 0xa4, 0x70,
	0x5f, 0x16, 0x96, 0x5d, 0xe4, 0x15, 0x6c, 0x63, 0x46, 0x9d, 0xcb, 0xb8, 0x15, 0x2a, 0x6e, 0xf7,
	0x5f, 0x06, 0x5b, 0xcb, 0x1d, 0x52, 0x71, 0x91, 0xd7, 0xf0, 0x9b, 0x5a, 0x13, 0xd6, 0x9d, 0x8b,
	0x58, 0xaf, 0x3d, 0x53, 0xb5, 0xd8, 0x45, 0x5e, 0xc9, 0xd7, 0x6e, 0xeb, 0x50, 0x6a, 0x6e, 0x68,
	0x7b, 0x30, 0xee, 0x4e, 0xc9, 0x82, 0x8b, 0xbc, 0x5c, 0xb8, 0xa1, 0x75, 0xbe, 0x98, 0x60, 0xcf,
	0x28, 0xa9, 0xba, 0xc8, 0x6b, 0x46, 0xed, 0x19, 0x8d, 0xdb, 0x33, 0x4a, 0x6a, 0x2e, 0xf2, 0xe6,
	0x23, 0xf6, 0x91, 0xfd, 0x6f, 0x8d, 0xf7, 0x7b, 0x83, 0x80, 0xd4, 0x5d, 0xe4, 0xa1, 0x70, 0xff,
	0x77, 0xc5, 0xaa, 0x7d, 0xa2, 0xd3, 0xdd, 0xfe, 0xe8, 0x05, 0x69, 0xb8, 0xc8, 0xab, 0x18, 0x27,
	0x2a, 0x56, 0xad, 0x0d, 0xf5, 0x0e, 0xa7, 0xc1, 0x1e, 0x69, 0xba, 0xc8, 0xab, 0x86, 0x1b, 0x5a,
	0xe5, 0x8b, 0xce, 0xa6, 0x91, 0x71, 0x28, 0x2f, 0x1a, 0x69, 0xb9, 0xc8, 0x5b, 0xe8, 0x5c, 0x3d,
	0xee, 0xbd, 0x84, 0xd7, 0x70, 0x53, 0x8a, 0x8a, 0x2f, 0x8c, 0xc3, 0x02, 0xed, 0x0e, 0x71, 0x84,
	0xf8, 0x52, 0x4a, 0xf1, 0x4e, 0x78, 0xbc, 0x6a, 0xc5, 0xf1, 0x70, 0x6d, 0x37, 0x98, 0x04, 0xdd,
	0x69, 0xb0, 0x25, 0xa1, 0xfb, 0x06, 0xb9, 0x79, 0xaf, 0xbc, 0x9a, 0x6b, 0x22, 0xbf, 0xaa, 0xfe,
	0x45, 0x90, 0xf7, 0x99, 0x51, 0x29, 0xc8, 0xfb, 0x96, 0x57, 0xa6, 0x44, 0xcf, 0xd6, 0x15, 0xf8,
	0x5d, 0xc2, 0x75, 0xad, 0x2b, 0x69, 0xf9, 0x8e, 0x0b, 0x17, 0x45, 0xa9, 0xb6, 0x94, 0x0c, 0x5e,
	0xc1, 0x0d, 0x5d, 0x0b, 0x0c, 0x7e, 0xcf, 0x8b, 0x5b, 0xa2, 0x58, 0xeb, 0x00, 0x88, 0x66, 0x35,
	0x80, 0xf8, 0x03, 0xaf, 0xae, 0xd9, 0xd5, 0x40, 0x63, 0x24, 0x07, 0xa3, 0xe4, 0x47, 0x5e, 0x9c,
	0x8f, 0xe5, 0x60, 0x34, 0x96, 0x83, 0x51, 0xf2, 0x13, 0x2f, 0x76, 0xe2, 0x39, 0x22, 0xd5, 0xc0,
	0xe5, 0x2b, 0x5e, 0x5d, 0x88, 0xe7, 0x60, 0xd4, 0x59, 0xc2, 0xad, 0x50, 0x5b, 0x01, 0xf7, 0x33,
	0xaf, 0x6f, 0x88, 0xfa, 0xa6, 0x56, 0x57, 0x84, 0xb6, 0xb1, 0x5e, 0xd3, 0x84, 0xfe, 0xc2, 0x1b,
	0x4a, 0xa2, 0x41, 0x9b, 0x2b, 0x4c, 0xcd, 0x9d, 0x4a, 0x4c, 0x7f, 0xe5, 0xd5, 0x39, 0x7b, 0xa7,
	0x92, 0xd5, 0x78, 0x1a, 0x46, 0xc9, 0x6f, 0xbc, 0xbc, 0x99, 0x94, 0x86, 0xd1, 0x78, 0x1a, 0x46,
	0xc9, 0xef, 0xbc, 0x61, 0x3e, 0x21, 0x4d, 0xe4, 0x74, 0x80, 0xda, 0x3f, 0x78, 0x39, 0xb2, 0x4f,
	0x07, 0xd0, 0xf5, 0xcc, 0x93, 0x97, 0xe8, 0xfe, 0xc9, 0xab, 0x2b, 0xc6, 0xa9, 0x4b, 0x76, 0xcf,
	0x1b, 0xbb, 0x94, 0xec, 0xfe, 0xc5, 0x0b, 0xab, 0xe1, 0x0e, 0x25, 0xbc, 0x4f, 0x8c, 0xbc, 0x0a,
	0xde, 0xbf, 0x79, 0x65, 0x16, 0x7a, 0x95, 0x92, 0xa2, 0xf7, 0x4b, 0xe3, 0xf8, 0x34, 0xbd, 0xff,
	0x48, 0xf5, 0x0c, 0xf8, 0x46, 0xe4, 0x3b, 0xce, 0x59, 0xbc, 0x30, 0x1a, 0x4f, 0xba, 0xcf, 0x77,
	0x24, 0xbc, 0x67, 0x80, 0xdd, 0x39, 0x1f, 0xcb, 0x65, 0x98, 0x99, 0xaa, 0x48, 0x70, 0xeb, 0x66,
	0xc2, 0x56, 0x4b, 0xc2, 0xcc, 0xac, 0x82, 0xa4, 0xe4, 0xea, 0x2d, 0x20, 0x76, 0xce, 0x07, 0x2b,
	0x35, 0x33, 0x6b, 0x50, 0x06, 0xb4, 0x2e, 0x02, 0xac, 0x73, 0x3e, 0xf4, 0xeb, 0x99, 0xa9, 0x0a,
	0x01, 0xd4, 0xb3, 0xc0, 0xa9, 0x2e, 0xd4, 0x33, 0xd3, 0x30, 0x66, 0x94, 0xbc, 0x0d, 0x88, 0x9a,
	0xc6, 0x62, 0x14, 0x98, 0xc6, 0x8c, 0x92, 0x73, 0x40, 0xa7, 0x65, 0x6c, 0x15, 0x02, 0x99, 0xe7,
	0x01, 0x4c, 0xcb, 0x58, 0xcc, 0xcc, 0x86, 0x52, 0x54, 0x8c, 0x5d, 0x00, 0x26, 0xe7, 0xfc, 0x3a,
	0x68, 0x86, 0x33, 0x13, 0x56, 0x34, 0x8f, 0x1e, 0xe0, 0x38, 0xe7, 0x83, 0x5f, 0x38, 0x33, 0xd5,
	0x86, 0x24, 0x8a, 0x17, 0x81, 0x44, 0xbd, 0x21, 0x35, 0x33, 0x6d, 0x7b, 0x46, 0xc9, 0x25, 0x80,
	0x30, 0x62, 0x2f, 0x66, 0xa6, 0x65, 0xcf, 0x28, 0xb9, 0x0c, 0xfc, 0xd9, 0xf6, 0xd6, 0xfe, 0x81,
	0xbd, 0x2b, 0x80, 0x9e, 0xde, 0xbf, 0x9e, 0x99, 0xfa, 0x44, 0x25, 0x76, 0xef, 0x70, 0xea, 0xac,
	0x13, 0x55, 0x33, 0x53, 0x6d, 0x48, 0x52, 0xd7, 0xe6, 0xd0, 0x99, 0x1b, 0x52, 0x33, 0x53, 0x65,
	0x54, 0xd0, 0x5d, 0xcd, 0xc4, 0x9c, 0xb9, 0xa9, 0x70, 0x66, 0x36, 0x6c, 0xed, 0x0e, 0x59, 0xca,
	0x86, 0x9c, 0x79, 0xbc, 0x1a, 0xba, 0x0d, 0x5c, 0x1e, 0x76, 0x27, 0x92, 0xb8, 0x65, 0xa1, 0x4b,
	0x8f, 0xad, 0xdb, 0x9d, 0x70, 0x24, 0xd7, 0x46, 0xd3, 0xdd, 0x43, 0xbf, 0x34, 0x94, 0x9f, 0x94,
	0xa0, 0xa0, 0x93, 0xa6, 0x16, 0xe4, 0x40, 0x86, 0x82, 0x02, 0x4f, 0x1f, 0x57, 0xb8, 0xa0, 0x44,
	0xe9, 0x9a, 0x50, 0xbc, 0x96, 0x42, 0x51, 0xc0, 0x2b, 0x25, 0x79, 0x30, 0xc9, 0xf2, 0x23, 0x8c,
	0xb9, 0x26, 0xf0, 0x79, 0x5d, 0x88, 0xb2, 0x14, 0xa2, 0x12, 0x60, 0xa9, 0xca, 0xd3, 0x01, 0xd0,
	0x61, 0x54, 0x46, 0xc9, 0x8d, 0x2c, 0x51, 0x19, 0xb5, 0xa2, 0x32, 0x6a, 0x46, 0x65, 0x94, 0xac,
	0x64, 0x8a, 0xaa, 0x54, 0x55, 0x54, 0x46, 0x55, 0x54, 0xc9, 0xe9, 0xad, 0xd4, 0x51, 0x05, 0xc8,
	0x61, 0x54, 0xc9, 0x35, 0x44, 0x05, 0xf8, 0xee, 0xa4, 0x8e, 0x2a, 0xe9, 0x0c, 0xa3, 0x02, 0xad,
	0x20, 0x0b, 0xa8, 0x7e, 0x90, 0x5a, 0x56, 0xb2, 0x1c, 0xca, 0x02, 0xdb, 0x70, 0x02, 0x12, 0xec,
	0xd5, 0xd4, 0x27, 0x20, 0xc8, 0x0f, 0x4f, 0x40, 0x3e, 0x08, 0x1e, 0xe3, 0x05, 0xae, 0xa9, 0x9e,
	0x02, 0x1f, 0x0a, 0xd5, 0xeb, 0x29, 0x54, 0xe1, 0xad, 0xd4, 0xe5, 0xdb, 0x56, 0x8f, 0x81, 0x27,
	0xb8, 0x6a, 0x28, 0x77, 0xc8, 0x5d, 0x21, 0x7d, 0x23, 0xbd, 0x34, 0xdc, 0xda, 0x85, 0x50, 0xbb,
	0xe3, 0x3c, 0xc5, 0x35, 0x2e, 0xbe, 0x13, 0x1c, 0x02, 0x66, 0xf7, 0x52, 0xab, 0xdf, 0x0f, 0x0e,
	0x0d, 0xd2, 0xb8, 0xba, 0x5a, 0x71, 0x9e, 0xe1, 0xba, 0x52, 0x07, 0xe0, 0xee, 0x0b, 0xf9, 0x77,
	0xd3, 0xc9, 0x9b, 0xcc, 0x55, 0x87, 0xc6, 0x52, 0x24, 0x3e, 0xa3, 0xe4, 0xa3, 0x8c, 0xf1, 0x15,
	0x27, 0x61, 0x7c, 0x46, 0xa3, 0xf1, 0x19, 0x25, 0x0f, 0xb2, 0xc6, 0x57, 0xfa, 0x46, 0x7c, 0xdb,
	0x00, 0xee, 0xf8, 0xa3, 0x2c, 0x06, 0xe6, 0x35, 0x07, 0x03, 0xb8, 0xe9, 0x3d, 0xdc, 0xd0, 0x4f,
	0x50, 0x38, 0xa1, 0x4d, 0xe1, 0xb0, 0x92, 0xf6, 0x39, 0x6a, 0x9c, 0x51, 0x6d, 0x68, 0xae, 0x39,
	0x3b, 0xd8, 0x09, 0x21, 0xd5, 0x00, 0x3c, 0x11, 0x36, 0xb7, 0x52, 0xc3, 0x6a, 0x61, 0xd0, 0x1c,
	0x46, 0x96, 0x9d, 0x11, 0xfe, 0x5f, 0xdc, 0xac, 0x43, 0x9e, 0x0a, 0xb7, 0xdb, 0x59, 0xdd, 0xe0,
	0x6e, 0xb5, 0xa2, 0x76, 0x9d, 0x53, 0x2b, 0xb8, 0x6a, 0x0e, 0x3b, 0xa7, 0x89, 0xf3, 0x3b, 0xc1,
	0xa1, 0xf8, 0x4d, 0xa7, 0xe8, 0xf3, 0xb7, 0xce, 0xff, 0x71, 0xf1, 0xa0, 0x3b, 0xd8, 0x0f, 0xc4,
	0x4f, 0x38, 0x65, 0x5f, 0x7e, 0x58, 0xc9, 0xdd, 0x40, 0xa7, 0xbe, 0x12, 0xbd, 0x7a, 0xae, 0x25,
	0xf4, 0xae, 0x9a, 0xbd, 0x69, 0x7f, 0xfe, 0x31, 0x9c, 0xde, 0xc3, 0x35, 0x6b, 0xde, 0xcd, 0x8a,
	0x59, 0x34, 0x9b, 0x6f, 0xe2, 0xba, 0x3d, 0xd7, 0xcc, 0xee, 0x5a, 0x42, 0x77, 0x2d, 0xd1, 0x1a,
	0x6e, 0x87, 0xd9, 0x9c, 0x4f, 0x68, 0xce, 0x27, 0x5b, 0x27, 0x74, 0x17, 0x12, 0xba, 0x0b, 0x71,
	0xeb, 0x70, 0x1e, 0xcd, 0xda, 0x75, 0x2e, 0x6e, 0x6d, 0xcc, 0x9d, 0x59, 0xdd, 0x28, 0xde, 0x6d,
	0x70, 0x37, 0xab, 0xbb, 0x12, 0x0f, 0x1e, 0x8e, 0x91, 0x59, 0xcd, 0x55, 0xb3, 0x79, 0x84, 0x1b,
	0x91, 0x69, 0x91, 0xd0, 0xbe, 0x66, 0xb6, 0x67, 0xf8, 0x06, 0x68, 0xf8, 0x4d, 0x70, 0x33, 0x3a,
	0x42, 0x12, 0x0c, 0xd7, 0x6d, 0xc3, 0xf4, 0x5f, 0x0a, 0x0d, 0xc7, 0xdb, 0xc2, 0xd1, 0x1a, 0x2b,
	0xa9, 0x2e, 0xf4, 0xfb, 0xb8, 0x15, 0x9b, 0x1b, 0xb3, 0xee, 0x74, 0xf1, 0xa8, 0x00, 0xc7, 0xbc,
	0xd6, 0x47, 0x07, 0x38, 0xe6, 0xcd, 0x4e, 0x16, 0x38, 0xe2, 0x86, 0x55, 0x66, 0x09, 0xdc, 0xc1,
	0x4e, 0xfc, 0xc1, 0x3d, 0xeb, 0x10, 0x2d, 0x34, 0xa7, 0xf8, 0x44, 0xe2, 0x33, 0x39, 0x21, 0xc6,
	0x1b, 0xbc, 0x6c, 0x07, 0xf8, 0x64, 0xf2, 0xb3, 0x39, 0xc1, 0xf6, 0x4d, 0x5e, 0xb9, 0x0a, 0x2e,
	0xc1, 0xf2, 0xa9, 0xc7, 0xb8, 0xac, 0xff, 0x77, 0x54, 0xc7, 0xb9, 0xde, 0x01, 0xfc, 0x80, 0x9f,
	0xeb, 0x1d, 0x38, 0x37, 0x71, 0x2e, 0x38, 0xc8, 0xf4, 0xb0, 0xce, 0x05, 0x07, 0x8b, 0x8b, 0xb8,
	0x20, 0xbe, 0xd6, 0x94, 0x71, 0x61, 0x73, 0xcd, 0xdf, 0x68, 0xce, 0x39, 0x25, 0x9c, 0xdf, 0x78,
	0xb0, 0xd6, 0x44, 0xfc, 0xcd, 0xc3, 0xcf, 0x37, 0x9a, 0xb9, 0xc5, 0x33, 0xb8, 0xb4, 0xf6, 0xb2,
	0x3b, 0x9c, 0x0c, 0x02, 0xfe, 0xb7, 0xd9, 0xee, 0x0f, 0x82, 0x2d, 0xf8, 0x7b, 0xc9, 0x0f, 0x97,
	0x8e, 0x21, 0xb2, 0x7a, 0xf2, 0xeb, 0xd7, 0xa7, 0xd1, 0xab, 0xd7, 0xa7, 0xd1, 0xbf, 0xaf, 0x4f,
	0xa3, 0xcd, 0x72, 0xfb, 0xaa, 0x8c, 0xd6, 0x9b, 0x97, 0xaf, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff,
	0xab, 0x75, 0x8c, 0xab, 0xdd, 0x18, 0x00, 0x00,
}

func (m *FieldTestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepeatedMessage2) > 0 {
		for iNdEx := len(m.RepeatedMessage2) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepeatedMessage2[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.RepeatedMessage) > 0 {
		for iNdEx := len(m.RepeatedMessage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepeatedMessage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedDouble)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xb2
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFixed64)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedSfixed64)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFloat)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFixed32)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x92
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedSfixed32)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x8a
	}
	if len(m.RepeatedUint64) > 0 {
		dAtA4 := make([]byte, len(m.RepeatedUint64)*10)
		var j3 int
		for _, num := range m.RepeatedUint64 {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintFields(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x82
	}
	if len(m.RepeatedSint64) > 0 {
		var j5 int
		dAtA7 := make([]byte, len(m.RepeatedSint64)*10)
		for _, num := range m.RepeatedSint64 {
			x6 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x6 >= 1<<7 {
				dAtA7[j5] = uint8(uint64(x6)&0x7f | 0x80)
				j5++
				x6 >>= 7
			}
			dAtA7[j5] = uint8(x6)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA7[:j5])
		i = encodeVarintFields(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xfa
	}
	if len(m.RepeatedInt64) > 0 {
		dAtA9 := make([]byte, len(m.RepeatedInt64)*10)
		var j8 int
		for _, num1 := range m.RepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintFields(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RepeatedUint32) > 0 {
		dAtA11 := make([]byte, len(m.RepeatedUint32)*10)
		var j10 int
		for _, num := range m.RepeatedUint32 {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintFields(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xea
	}
	if len(m.RepeatedSint32) > 0 {
		dAtA12 := make([]byte, len(m.RepeatedSint32)*5)
		var j13 int
		for _, num := range m.RepeatedSint32 {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				dAtA12[j13] = uint8(uint64(x14)&0x7f | 0x80)
				j13++
				x14 >>= 7
			}
			dAtA12[j13] = uint8(x14)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA12[:j13])
		i = encodeVarintFields(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RepeatedInt32) > 0 {
		dAtA16 := make([]byte, len(m.RepeatedInt32)*10)
		var j15 int
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintFields(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xda
	}
	if len(m.RepeatedEnum) > 0 {
		dAtA18 := make([]byte, len(m.RepeatedEnum)*10)
		var j17 int
		for _, num := range m.RepeatedEnum {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintFields(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedBool)))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if len(m.MapStringMessage2) > 0 {
		for k := range m.MapStringMessage2 {
			v := m.MapStringMessage2[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapStringMessage) > 0 {
		for k := range m.MapStringMessage {
			v := m.MapStringMessage[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapInt32Int64) > 0 {
		for k := range m.MapInt32Int64 {
			v := m.MapInt32Int64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapKeyString) > 0 {
		for k := range m.MapKeyString {
			v := m.MapKeyString[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapKeyUint64) > 0 {
		for k := range m.MapKeyUint64 {
			v := m.MapKeyUint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapKeyInt64) > 0 {
		for k := range m.MapKeyInt64 {
			v := m.MapKeyInt64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapKeyUint32) > 0 {
		for k := range m.MapKeyUint32 {
			v := m.MapKeyUint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapKeyInt32) > 0 {
		for k := range m.MapKeyInt32 {
			v := m.MapKeyInt32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapMessage2) > 0 {
		for k := range m.MapMessage2 {
			v := m.MapMessage2[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapMessage) > 0 {
		for k := range m.MapMessage {
			v := m.MapMessage[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapBytes) > 0 {
		for k := range m.MapBytes {
			v := m.MapBytes[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFields(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapString) > 0 {
		for k := range m.MapString {
			v := m.MapString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFields(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapDouble) > 0 {
		for k := range m.MapDouble {
			v := m.MapDouble[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapFloat) > 0 {
		for k := range m.MapFloat {
			v := m.MapFloat[k]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapUint64) > 0 {
		for k := range m.MapUint64 {
			v := m.MapUint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapInt64) > 0 {
		for k := range m.MapInt64 {
			v := m.MapInt64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapUint32) > 0 {
		for k := range m.MapUint32 {
			v := m.MapUint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapInt32) > 0 {
		for k := range m.MapInt32 {
			v := m.MapInt32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapEnum) > 0 {
		for k := range m.MapEnum {
			v := m.MapEnum[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapBool) > 0 {
		for k := range m.MapBool {
			v := m.MapBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.NopackMessage2) > 0 {
		for iNdEx := len(m.NopackMessage2) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NopackMessage2[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.NopackMessage) > 0 {
		for iNdEx := len(m.NopackMessage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NopackMessage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.NopackBytes) > 0 {
		for iNdEx := len(m.NopackBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NopackBytes[iNdEx])
			copy(dAtA[i:], m.NopackBytes[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.NopackBytes[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.NopackString) > 0 {
		for iNdEx := len(m.NopackString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NopackString[iNdEx])
			copy(dAtA[i:], m.NopackString[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.NopackString[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.NopackDouble) > 0 {
		for iNdEx := len(m.NopackDouble) - 1; iNdEx >= 0; iNdEx-- {
			f23 := math.Float64bits(float64(m.NopackDouble[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f23))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe1
		}
	}
	if len(m.NopackFixed64) > 0 {
		for iNdEx := len(m.NopackFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NopackFixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd9
		}
	}
	if len(m.NopackSfixed64) > 0 {
		for iNdEx := len(m.NopackSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NopackSfixed64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xd1
		}
	}
	if len(m.NopackFloat) > 0 {
		for iNdEx := len(m.NopackFloat) - 1; iNdEx >= 0; iNdEx-- {
			f24 := math.Float32bits(float32(m.NopackFloat[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xcd
		}
	}
	if len(m.NopackFixed32) > 0 {
		for iNdEx := len(m.NopackFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NopackFixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc5
		}
	}
	if len(m.NopackSfixed32) > 0 {
		for iNdEx := len(m.NopackSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NopackSfixed32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xbd
		}
	}
	if len(m.NopackUint64) > 0 {
		for iNdEx := len(m.NopackUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFields(dAtA, i, uint64(m.NopackUint64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb0
		}
	}
	if len(m.NopackSint64) > 0 {
		for iNdEx := len(m.NopackSint64) - 1; iNdEx >= 0; iNdEx-- {
			x25 := (uint64(m.NopackSint64[iNdEx]) << 1) ^ uint64((m.NopackSint64[iNdEx] >> 63))
			i = encodeVarintFields(dAtA, i, uint64(x25))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa8
		}
	}
	if len(m.NopackInt64) > 0 {
		for iNdEx := len(m.NopackInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFields(dAtA, i, uint64(m.NopackInt64[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa0
		}
	}
	if len(m.NopackUint32) > 0 {
		for iNdEx := len(m.NopackUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFields(dAtA, i, uint64(m.NopackUint32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x98
		}
	}
	if len(m.NopackSint32) > 0 {
		for iNdEx := len(m.NopackSint32) - 1; iNdEx >= 0; iNdEx-- {
			x26 := (uint32(m.NopackSint32[iNdEx]) << 1) ^ uint32((m.NopackSint32[iNdEx] >> 31))
			i = encodeVarintFields(dAtA, i, uint64(x26))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x90
		}
	}
	if len(m.NopackInt32) > 0 {
		for iNdEx := len(m.NopackInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFields(dAtA, i, uint64(m.NopackInt32[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x88
		}
	}
	if len(m.NopackEnum) > 0 {
		for iNdEx := len(m.NopackEnum) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintFields(dAtA, i, uint64(m.NopackEnum[iNdEx]))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x80
		}
	}
	if len(m.NopackBool) > 0 {
		for iNdEx := len(m.NopackBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.NopackBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf8
		}
	}
	if m.OptionalMessage2 != nil {
		{
			size, err := m.OptionalMessage2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFields(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.OptionalMessage != nil {
		{
			size, err := m.OptionalMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFields(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.OptionalBytes) > 0 {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarintFields(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.OptionalString) > 0 {
		i -= len(m.OptionalString)
		copy(dAtA[i:], m.OptionalString)
		i = encodeVarintFields(dAtA, i, uint64(len(m.OptionalString)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OptionalDouble != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionalDouble))))
		i--
		dAtA[i] = 0x71
	}
	if m.OptionalFixed64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalFixed64))
		i--
		dAtA[i] = 0x69
	}
	if m.OptionalSfixed64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalSfixed64))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalFixed32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalFixed32))
		i--
		dAtA[i] = 0x55
	}
	if m.OptionalSfixed32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalUint64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalUint64))
		i--
		dAtA[i] = 0x40
	}
	if m.OptionalSint64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64((uint64(m.OptionalSint64)<<1)^uint64((m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x38
	}
	if m.OptionalInt64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalInt64))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalUint32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalUint32))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalSint32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64((uint32(m.OptionalSint32)<<1)^uint32((m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalInt32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalInt32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalEnum != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalEnum))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalBool {
		i--
		if m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldTestMessage_Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage_Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FieldTestMessage_Message2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage_Message2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage_Message2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ev != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.Ev))
		i--
		dAtA[i] = 0x10
	}
	if m.Bv {
		i--
		if m.Bv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Example) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Example) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Example) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filed != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.Filed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFields(dAtA []byte, offset int, v uint64) int {
	offset -= sovFields(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FieldTestMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalBool {
		n += 2
	}
	if m.OptionalEnum != 0 {
		n += 1 + sovFields(uint64(m.OptionalEnum))
	}
	if m.OptionalInt32 != 0 {
		n += 1 + sovFields(uint64(m.OptionalInt32))
	}
	if m.OptionalSint32 != 0 {
		n += 1 + sozFields(uint64(m.OptionalSint32))
	}
	if m.OptionalUint32 != 0 {
		n += 1 + sovFields(uint64(m.OptionalUint32))
	}
	if m.OptionalInt64 != 0 {
		n += 1 + sovFields(uint64(m.OptionalInt64))
	}
	if m.OptionalSint64 != 0 {
		n += 1 + sozFields(uint64(m.OptionalSint64))
	}
	if m.OptionalUint64 != 0 {
		n += 1 + sovFields(uint64(m.OptionalUint64))
	}
	if m.OptionalSfixed32 != 0 {
		n += 5
	}
	if m.OptionalFixed32 != 0 {
		n += 5
	}
	if m.OptionalFloat != 0 {
		n += 5
	}
	if m.OptionalSfixed64 != 0 {
		n += 9
	}
	if m.OptionalFixed64 != 0 {
		n += 9
	}
	if m.OptionalDouble != 0 {
		n += 9
	}
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sovFields(uint64(l))
	}
	l = len(m.OptionalBytes)
	if l > 0 {
		n += 2 + l + sovFields(uint64(l))
	}
	if m.OptionalMessage != nil {
		l = m.OptionalMessage.Size()
		n += 2 + l + sovFields(uint64(l))
	}
	if m.OptionalMessage2 != nil {
		l = m.OptionalMessage2.Size()
		n += 2 + l + sovFields(uint64(l))
	}
	if len(m.NopackBool) > 0 {
		n += 3 * len(m.NopackBool)
	}
	if len(m.NopackEnum) > 0 {
		for _, e := range m.NopackEnum {
			n += 2 + sovFields(uint64(e))
		}
	}
	if len(m.NopackInt32) > 0 {
		for _, e := range m.NopackInt32 {
			n += 2 + sovFields(uint64(e))
		}
	}
	if len(m.NopackSint32) > 0 {
		for _, e := range m.NopackSint32 {
			n += 2 + sozFields(uint64(e))
		}
	}
	if len(m.NopackUint32) > 0 {
		for _, e := range m.NopackUint32 {
			n += 2 + sovFields(uint64(e))
		}
	}
	if len(m.NopackInt64) > 0 {
		for _, e := range m.NopackInt64 {
			n += 2 + sovFields(uint64(e))
		}
	}
	if len(m.NopackSint64) > 0 {
		for _, e := range m.NopackSint64 {
			n += 2 + sozFields(uint64(e))
		}
	}
	if len(m.NopackUint64) > 0 {
		for _, e := range m.NopackUint64 {
			n += 2 + sovFields(uint64(e))
		}
	}
	if len(m.NopackSfixed32) > 0 {
		n += 6 * len(m.NopackSfixed32)
	}
	if len(m.NopackFixed32) > 0 {
		n += 6 * len(m.NopackFixed32)
	}
	if len(m.NopackFloat) > 0 {
		n += 6 * len(m.NopackFloat)
	}
	if len(m.NopackSfixed64) > 0 {
		n += 10 * len(m.NopackSfixed64)
	}
	if len(m.NopackFixed64) > 0 {
		n += 10 * len(m.NopackFixed64)
	}
	if len(m.NopackDouble) > 0 {
		n += 10 * len(m.NopackDouble)
	}
	if len(m.NopackString) > 0 {
		for _, s := range m.NopackString {
			l = len(s)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.NopackBytes) > 0 {
		for _, b := range m.NopackBytes {
			l = len(b)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.NopackMessage) > 0 {
		for _, e := range m.NopackMessage {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.NopackMessage2) > 0 {
		for _, e := range m.NopackMessage2 {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.MapBool) > 0 {
		for k, v := range m.MapBool {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 1
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapEnum) > 0 {
		for k, v := range m.MapEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32) > 0 {
		for k, v := range m.MapInt32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint32) > 0 {
		for k, v := range m.MapUint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64) > 0 {
		for k, v := range m.MapInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint64) > 0 {
		for k, v := range m.MapUint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapFloat) > 0 {
		for k, v := range m.MapFloat {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapDouble) > 0 {
		for k, v := range m.MapDouble {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapString) > 0 {
		for k, v := range m.MapString {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + len(v) + sovFields(uint64(len(v)))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapBytes) > 0 {
		for k, v := range m.MapBytes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFields(uint64(len(v)))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapMessage) > 0 {
		for k, v := range m.MapMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapMessage2) > 0 {
		for k, v := range m.MapMessage2 {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyInt32) > 0 {
		for k, v := range m.MapKeyInt32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyUint32) > 0 {
		for k, v := range m.MapKeyUint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyInt64) > 0 {
		for k, v := range m.MapKeyInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyUint64) > 0 {
		for k, v := range m.MapKeyUint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyString) > 0 {
		for k, v := range m.MapKeyString {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Int64) > 0 {
		for k, v := range m.MapInt32Int64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringMessage) > 0 {
		for k, v := range m.MapStringMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringMessage2) > 0 {
		for k, v := range m.MapStringMessage2 {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.RepeatedBool) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedBool))) + len(m.RepeatedBool)*1
	}
	if len(m.RepeatedEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedEnum {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSint32) > 0 {
		l = 0
		for _, e := range m.RepeatedSint32 {
			l += sozFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedUint32) > 0 {
		l = 0
		for _, e := range m.RepeatedUint32 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedInt64) > 0 {
		l = 0
		for _, e := range m.RepeatedInt64 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSint64) > 0 {
		l = 0
		for _, e := range m.RepeatedSint64 {
			l += sozFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedUint64) > 0 {
		l = 0
		for _, e := range m.RepeatedUint64 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedSfixed32)*4)) + len(m.RepeatedSfixed32)*4
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFixed32)*4)) + len(m.RepeatedFixed32)*4
	}
	if len(m.RepeatedFloat) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFloat)*4)) + len(m.RepeatedFloat)*4
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedSfixed64)*8)) + len(m.RepeatedSfixed64)*8
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFixed64)*8)) + len(m.RepeatedFixed64)*8
	}
	if len(m.RepeatedDouble) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedDouble)*8)) + len(m.RepeatedDouble)*8
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.RepeatedMessage) > 0 {
		for _, e := range m.RepeatedMessage {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.RepeatedMessage2) > 0 {
		for _, e := range m.RepeatedMessage2 {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldTestMessage_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldTestMessage_Message2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bv {
		n += 2
	}
	if m.Ev != 0 {
		n += 1 + sovFields(uint64(m.Ev))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Example) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filed != 0 {
		n += 1 + sovFields(uint64(m.Filed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFields(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFields(x uint64) (n int) {
	return sovFields(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FieldTestMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldTestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldTestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalBool = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalEnum", wireType)
			}
			m.OptionalEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalEnum |= FieldTestMessage_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			m.OptionalUint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.OptionalSint64 = int64(v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			m.OptionalUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			m.OptionalSfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed32 = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			m.OptionalFixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed32 = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalFloat = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			m.OptionalSfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed64 = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			m.OptionalFixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalDouble = float64(math.Float64frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalMessage == nil {
				m.OptionalMessage = &FieldTestMessage_Message{}
			}
			if err := m.OptionalMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalMessage2 == nil {
				m.OptionalMessage2 = &FieldTestMessage_Message2{}
			}
			if err := m.OptionalMessage2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackBool = append(m.NopackBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.NopackBool) == 0 {
					m.NopackBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackBool = append(m.NopackBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackBool", wireType)
			}
		case 32:
			if wireType == 0 {
				var v FieldTestMessage_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FieldTestMessage_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackEnum = append(m.NopackEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.NopackEnum) == 0 {
					m.NopackEnum = make([]FieldTestMessage_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FieldTestMessage_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackEnum = append(m.NopackEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackEnum", wireType)
			}
		case 33:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackInt32 = append(m.NopackInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackInt32) == 0 {
					m.NopackInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackInt32 = append(m.NopackInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackInt32", wireType)
			}
		case 34:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.NopackSint32 = append(m.NopackSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackSint32) == 0 {
					m.NopackSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.NopackSint32 = append(m.NopackSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackSint32", wireType)
			}
		case 35:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackUint32 = append(m.NopackUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackUint32) == 0 {
					m.NopackUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackUint32 = append(m.NopackUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackUint32", wireType)
			}
		case 36:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackInt64 = append(m.NopackInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackInt64) == 0 {
					m.NopackInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackInt64 = append(m.NopackInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackInt64", wireType)
			}
		case 37:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.NopackSint64 = append(m.NopackSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackSint64) == 0 {
					m.NopackSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.NopackSint64 = append(m.NopackSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackSint64", wireType)
			}
		case 38:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NopackUint64 = append(m.NopackUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NopackUint64) == 0 {
					m.NopackUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NopackUint64 = append(m.NopackUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackUint64", wireType)
			}
		case 39:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.NopackSfixed32 = append(m.NopackSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NopackSfixed32) == 0 {
					m.NopackSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.NopackSfixed32 = append(m.NopackSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackSfixed32", wireType)
			}
		case 40:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.NopackFixed32 = append(m.NopackFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NopackFixed32) == 0 {
					m.NopackFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.NopackFixed32 = append(m.NopackFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackFixed32", wireType)
			}
		case 41:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.NopackFloat = append(m.NopackFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NopackFloat) == 0 {
					m.NopackFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.NopackFloat = append(m.NopackFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackFloat", wireType)
			}
		case 42:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.NopackSfixed64 = append(m.NopackSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NopackSfixed64) == 0 {
					m.NopackSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.NopackSfixed64 = append(m.NopackSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackSfixed64", wireType)
			}
		case 43:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.NopackFixed64 = append(m.NopackFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NopackFixed64) == 0 {
					m.NopackFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.NopackFixed64 = append(m.NopackFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackFixed64", wireType)
			}
		case 44:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.NopackDouble = append(m.NopackDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NopackDouble) == 0 {
					m.NopackDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.NopackDouble = append(m.NopackDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackDouble", wireType)
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NopackString = append(m.NopackString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NopackBytes = append(m.NopackBytes, make([]byte, postIndex-iNdEx))
			copy(m.NopackBytes[len(m.NopackBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NopackMessage = append(m.NopackMessage, &FieldTestMessage_Message{})
			if err := m.NopackMessage[len(m.NopackMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NopackMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NopackMessage2 = append(m.NopackMessage2, &FieldTestMessage_Message2{})
			if err := m.NopackMessage2[len(m.NopackMessage2)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBool == nil {
				m.MapBool = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBool[mapkey] = mapvalue
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapEnum == nil {
				m.MapEnum = make(map[int32]FieldTestMessage_Enum)
			}
			var mapkey int32
			var mapvalue FieldTestMessage_Enum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32 == nil {
				m.MapInt32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32[mapkey] = mapvalue
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint32 == nil {
				m.MapUint32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64 == nil {
				m.MapInt64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint64 == nil {
				m.MapUint64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFloat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFloat == nil {
				m.MapFloat = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFloat[mapkey] = mapvalue
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapDouble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapDouble == nil {
				m.MapDouble = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapDouble[mapkey] = mapvalue
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapString == nil {
				m.MapString = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapString[mapkey] = mapvalue
			iNdEx = postIndex
		case 66:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBytes == nil {
				m.MapBytes = make(map[int32][]byte)
			}
			var mapkey int32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFields
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBytes[mapkey] = mapvalue
			iNdEx = postIndex
		case 67:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapMessage == nil {
				m.MapMessage = make(map[int32]*FieldTestMessage_Message)
			}
			var mapkey int32
			var mapvalue *FieldTestMessage_Message
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 68:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapMessage2 == nil {
				m.MapMessage2 = make(map[int32]*FieldTestMessage_Message2)
			}
			var mapkey int32
			var mapvalue *FieldTestMessage_Message2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapMessage2[mapkey] = mapvalue
			iNdEx = postIndex
		case 73:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyInt32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyInt32 == nil {
				m.MapKeyInt32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyInt32[mapkey] = mapvalue
			iNdEx = postIndex
		case 75:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyUint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyUint32 == nil {
				m.MapKeyUint32 = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyUint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 76:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyInt64 == nil {
				m.MapKeyInt64 = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyInt64[mapkey] = mapvalue
			iNdEx = postIndex
		case 78:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyUint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyUint64 == nil {
				m.MapKeyUint64 = make(map[uint64]int32)
			}
			var mapkey uint64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyUint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 85:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyString == nil {
				m.MapKeyString = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyString[mapkey] = mapvalue
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Int64 == nil {
				m.MapInt32Int64 = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Int64[mapkey] = mapvalue
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringMessage == nil {
				m.MapStringMessage = make(map[string]*FieldTestMessage_Message)
			}
			var mapkey string
			var mapvalue *FieldTestMessage_Message
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 92:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringMessage2 == nil {
				m.MapStringMessage2 = make(map[string]*FieldTestMessage_Message2)
			}
			var mapkey string
			var mapvalue *FieldTestMessage_Message2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringMessage2[mapkey] = mapvalue
			iNdEx = postIndex
		case 201:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RepeatedBool) == 0 {
					m.RepeatedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 202:
			if wireType == 0 {
				var v FieldTestMessage_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FieldTestMessage_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedEnum = append(m.RepeatedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedEnum) == 0 {
					m.RepeatedEnum = make([]FieldTestMessage_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FieldTestMessage_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedEnum = append(m.RepeatedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedEnum", wireType)
			}
		case 203:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 204:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint32) == 0 {
					m.RepeatedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 205:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint32) == 0 {
					m.RepeatedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 206:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt64) == 0 {
					m.RepeatedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 207:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint64) == 0 {
					m.RepeatedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 208:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint64) == 0 {
					m.RepeatedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 209:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedSfixed32) == 0 {
					m.RepeatedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 210:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFixed32) == 0 {
					m.RepeatedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 211:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFloat) == 0 {
					m.RepeatedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 212:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedSfixed64) == 0 {
					m.RepeatedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 213:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedFixed64) == 0 {
					m.RepeatedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 214:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedDouble) == 0 {
					m.RepeatedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 215:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 216:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 217:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedMessage = append(m.RepeatedMessage, &FieldTestMessage_Message{})
			if err := m.RepeatedMessage[len(m.RepeatedMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 218:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedMessage2 = append(m.RepeatedMessage2, &FieldTestMessage_Message2{})
			if err := m.RepeatedMessage2[len(m.RepeatedMessage2)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldTestMessage_Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldTestMessage_Message2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bv = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ev", wireType)
			}
			m.Ev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ev |= FieldTestMessage_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Example) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Example: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Example: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filed", wireType)
			}
			m.Filed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFields(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFields
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFields
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFields
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFields
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFields
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFields
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFields        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFields          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFields = fmt.Errorf("proto: unexpected end of group")
)
