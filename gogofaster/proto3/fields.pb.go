// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fields.proto

package proto3

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Enum int32

const (
	Enum_ZERO Enum = 0
	Enum_ONE  Enum = 1
	Enum_TWO  Enum = 2
)

var Enum_name = map[int32]string{
	0: "ZERO",
	1: "ONE",
	2: "TWO",
}

var Enum_value = map[string]int32{
	"ZERO": 0,
	"ONE":  1,
	"TWO":  2,
}

func (x Enum) String() string {
	return proto.EnumName(Enum_name, int32(x))
}

func (Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0}
}

type FieldTestMessage_Enum int32

const (
	FieldTestMessage_ZERO FieldTestMessage_Enum = 0
	FieldTestMessage_ONE  FieldTestMessage_Enum = 1
	FieldTestMessage_TWO  FieldTestMessage_Enum = 2
)

var FieldTestMessage_Enum_name = map[int32]string{
	0: "ZERO",
	1: "ONE",
	2: "TWO",
}

var FieldTestMessage_Enum_value = map[string]int32{
	"ZERO": 0,
	"ONE":  1,
	"TWO":  2,
}

func (x FieldTestMessage_Enum) String() string {
	return proto.EnumName(FieldTestMessage_Enum_name, int32(x))
}

func (FieldTestMessage_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 0}
}

type FieldTestMessage struct {
	OptionalBool      bool                                 `protobuf:"varint,1,opt,name=optional_bool,json=optionalBool,proto3" json:"optional_bool,omitempty"`
	OptionalEnum      FieldTestMessage_Enum                `protobuf:"varint,2,opt,name=optional_enum,json=optionalEnum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"optional_enum,omitempty"`
	OptionalInt32     int32                                `protobuf:"varint,3,opt,name=optional_int32,json=optionalInt32,proto3" json:"optional_int32,omitempty"`
	OptionalSint32    int32                                `protobuf:"zigzag32,4,opt,name=optional_sint32,json=optionalSint32,proto3" json:"optional_sint32,omitempty"`
	OptionalUint32    uint32                               `protobuf:"varint,5,opt,name=optional_uint32,json=optionalUint32,proto3" json:"optional_uint32,omitempty"`
	OptionalInt64     int64                                `protobuf:"varint,6,opt,name=optional_int64,json=optionalInt64,proto3" json:"optional_int64,omitempty"`
	OptionalSint64    int64                                `protobuf:"zigzag64,7,opt,name=optional_sint64,json=optionalSint64,proto3" json:"optional_sint64,omitempty"`
	OptionalUint64    uint64                               `protobuf:"varint,8,opt,name=optional_uint64,json=optionalUint64,proto3" json:"optional_uint64,omitempty"`
	OptionalSfixed32  int32                                `protobuf:"fixed32,9,opt,name=optional_sfixed32,json=optionalSfixed32,proto3" json:"optional_sfixed32,omitempty"`
	OptionalFixed32   uint32                               `protobuf:"fixed32,10,opt,name=optional_fixed32,json=optionalFixed32,proto3" json:"optional_fixed32,omitempty"`
	OptionalFloat     float32                              `protobuf:"fixed32,11,opt,name=optional_float,json=optionalFloat,proto3" json:"optional_float,omitempty"`
	OptionalSfixed64  int64                                `protobuf:"fixed64,12,opt,name=optional_sfixed64,json=optionalSfixed64,proto3" json:"optional_sfixed64,omitempty"`
	OptionalFixed64   uint64                               `protobuf:"fixed64,13,opt,name=optional_fixed64,json=optionalFixed64,proto3" json:"optional_fixed64,omitempty"`
	OptionalDouble    float64                              `protobuf:"fixed64,14,opt,name=optional_double,json=optionalDouble,proto3" json:"optional_double,omitempty"`
	OptionalString    string                               `protobuf:"bytes,15,opt,name=optional_string,json=optionalString,proto3" json:"optional_string,omitempty"`
	OptionalBytes     []byte                               `protobuf:"bytes,16,opt,name=optional_bytes,json=optionalBytes,proto3" json:"optional_bytes,omitempty"`
	Optional_Message  *FieldTestMessage_Message            `protobuf:"bytes,17,opt,name=optional_Message,json=optionalMessage,proto3" json:"optional_Message,omitempty"`
	Optional_Message2 *FieldTestMessage_Message2           `protobuf:"bytes,18,opt,name=optional_Message2,json=optionalMessage2,proto3" json:"optional_Message2,omitempty"`
	RepeatedBool      []bool                               `protobuf:"varint,201,rep,packed,name=repeated_bool,json=repeatedBool,proto3" json:"repeated_bool,omitempty"`
	RepeatedEnum      []FieldTestMessage_Enum              `protobuf:"varint,202,rep,packed,name=repeated_enum,json=repeatedEnum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"repeated_enum,omitempty"`
	RepeatedInt32     []int32                              `protobuf:"varint,203,rep,packed,name=repeated_int32,json=repeatedInt32,proto3" json:"repeated_int32,omitempty"`
	RepeatedSint32    []int32                              `protobuf:"zigzag32,204,rep,packed,name=repeated_sint32,json=repeatedSint32,proto3" json:"repeated_sint32,omitempty"`
	RepeatedUint32    []uint32                             `protobuf:"varint,205,rep,packed,name=repeated_uint32,json=repeatedUint32,proto3" json:"repeated_uint32,omitempty"`
	RepeatedInt64     []int64                              `protobuf:"varint,206,rep,packed,name=repeated_int64,json=repeatedInt64,proto3" json:"repeated_int64,omitempty"`
	RepeatedSint64    []int64                              `protobuf:"zigzag64,207,rep,packed,name=repeated_sint64,json=repeatedSint64,proto3" json:"repeated_sint64,omitempty"`
	RepeatedUint64    []uint64                             `protobuf:"varint,208,rep,packed,name=repeated_uint64,json=repeatedUint64,proto3" json:"repeated_uint64,omitempty"`
	RepeatedSfixed32  []int32                              `protobuf:"fixed32,209,rep,packed,name=repeated_sfixed32,json=repeatedSfixed32,proto3" json:"repeated_sfixed32,omitempty"`
	RepeatedFixed32   []uint32                             `protobuf:"fixed32,210,rep,packed,name=repeated_fixed32,json=repeatedFixed32,proto3" json:"repeated_fixed32,omitempty"`
	RepeatedFloat     []float32                            `protobuf:"fixed32,211,rep,packed,name=repeated_float,json=repeatedFloat,proto3" json:"repeated_float,omitempty"`
	RepeatedSfixed64  []int64                              `protobuf:"fixed64,212,rep,packed,name=repeated_sfixed64,json=repeatedSfixed64,proto3" json:"repeated_sfixed64,omitempty"`
	RepeatedFixed64   []uint64                             `protobuf:"fixed64,213,rep,packed,name=repeated_fixed64,json=repeatedFixed64,proto3" json:"repeated_fixed64,omitempty"`
	RepeatedDouble    []float64                            `protobuf:"fixed64,214,rep,packed,name=repeated_double,json=repeatedDouble,proto3" json:"repeated_double,omitempty"`
	RepeatedString    []string                             `protobuf:"bytes,215,rep,name=repeated_string,json=repeatedString,proto3" json:"repeated_string,omitempty"`
	RepeatedBytes     [][]byte                             `protobuf:"bytes,216,rep,name=repeated_bytes,json=repeatedBytes,proto3" json:"repeated_bytes,omitempty"`
	Repeated_Message  []*FieldTestMessage_Message          `protobuf:"bytes,217,rep,name=repeated_Message,json=repeatedMessage,proto3" json:"repeated_Message,omitempty"`
	Repeated_Message2 []*FieldTestMessage_Message2         `protobuf:"bytes,218,rep,name=repeated_Message2,json=repeatedMessage2,proto3" json:"repeated_Message2,omitempty"`
	MapBool           map[int32]bool                       `protobuf:"bytes,301,rep,name=map_bool,json=mapBool,proto3" json:"map_bool,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapEnum           map[int32]FieldTestMessage_Enum      `protobuf:"bytes,302,rep,name=map_enum,json=mapEnum,proto3" json:"map_enum,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum"`
	MapInt32          map[int32]int32                      `protobuf:"bytes,303,rep,name=map_int32,json=mapInt32,proto3" json:"map_int32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapSint32         map[int32]int32                      `protobuf:"bytes,304,rep,name=map_sint32,json=mapSint32,proto3" json:"map_sint32,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	MapUint32         map[uint32]uint32                    `protobuf:"bytes,305,rep,name=map_uint32,json=mapUint32,proto3" json:"map_uint32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapInt64          map[int64]int64                      `protobuf:"bytes,306,rep,name=map_int64,json=mapInt64,proto3" json:"map_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapSint64         map[int64]int64                      `protobuf:"bytes,307,rep,name=map_sint64,json=mapSint64,proto3" json:"map_sint64,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	MapUint64         map[uint64]uint64                    `protobuf:"bytes,308,rep,name=map_uint64,json=mapUint64,proto3" json:"map_uint64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapSfixed32       map[int32]int32                      `protobuf:"bytes,309,rep,name=map_sfixed32,json=mapSfixed32,proto3" json:"map_sfixed32,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	MapFixed32        map[uint32]uint32                    `protobuf:"bytes,310,rep,name=map_fixed32,json=mapFixed32,proto3" json:"map_fixed32,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	MapFloat          map[int32]float32                    `protobuf:"bytes,311,rep,name=map_float,json=mapFloat,proto3" json:"map_float,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	MapSfixed64       map[int32]int64                      `protobuf:"bytes,312,rep,name=map_sfixed64,json=mapSfixed64,proto3" json:"map_sfixed64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	MapFixed64        map[int32]uint64                     `protobuf:"bytes,313,rep,name=map_fixed64,json=mapFixed64,proto3" json:"map_fixed64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	MapDouble         map[int32]float64                    `protobuf:"bytes,314,rep,name=map_double,json=mapDouble,proto3" json:"map_double,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	MapString         map[int32]string                     `protobuf:"bytes,315,rep,name=map_string,json=mapString,proto3" json:"map_string,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapBytes          map[int32][]byte                     `protobuf:"bytes,316,rep,name=map_bytes,json=mapBytes,proto3" json:"map_bytes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Map_Message       map[int32]*FieldTestMessage_Message  `protobuf:"bytes,317,rep,name=map_Message,json=mapMessage,proto3" json:"map_Message,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Map_Message2      map[int32]*FieldTestMessage_Message2 `protobuf:"bytes,318,rep,name=map_Message2,json=mapMessage2,proto3" json:"map_Message2,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//	map<bool,int32> map_key_bool = 401;
	//
	// map<Enum,int32> map_key_enum = 402;
	MapKeyInt32    map[int32]int32  `protobuf:"bytes,403,rep,name=map_key_int32,json=mapKeyInt32,proto3" json:"map_key_int32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeySint32   map[int32]int32  `protobuf:"bytes,404,rep,name=map_key_sint32,json=mapKeySint32,proto3" json:"map_key_sint32,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyUint32   map[uint32]int32 `protobuf:"bytes,405,rep,name=map_key_uint32,json=mapKeyUint32,proto3" json:"map_key_uint32,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyInt64    map[int64]int32  `protobuf:"bytes,406,rep,name=map_key_int64,json=mapKeyInt64,proto3" json:"map_key_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeySint64   map[int64]int32  `protobuf:"bytes,407,rep,name=map_key_sint64,json=mapKeySint64,proto3" json:"map_key_sint64,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyUint64   map[uint64]int32 `protobuf:"bytes,408,rep,name=map_key_uint64,json=mapKeyUint64,proto3" json:"map_key_uint64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeySfixed32 map[int32]int32  `protobuf:"bytes,409,rep,name=map_key_sfixed32,json=mapKeySfixed32,proto3" json:"map_key_sfixed32,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyFixed32  map[uint32]int32 `protobuf:"bytes,410,rep,name=map_key_fixed32,json=mapKeyFixed32,proto3" json:"map_key_fixed32,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map<float,int32> map_key_float = 411;
	MapKeySfixed64 map[int64]int32  `protobuf:"bytes,412,rep,name=map_key_sfixed64,json=mapKeySfixed64,proto3" json:"map_key_sfixed64,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapKeyFixed64  map[uint64]int32 `protobuf:"bytes,413,rep,name=map_key_fixed64,json=mapKeyFixed64,proto3" json:"map_key_fixed64,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map<double,int32> map_key_double = 414;
	MapKeyString      map[string]int32                      `protobuf:"bytes,415,rep,name=map_key_string,json=mapKeyString,proto3" json:"map_key_string,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapInt32Int64     map[int32]int64                       `protobuf:"bytes,500,rep,name=map_int32_int64,json=mapInt32Int64,proto3" json:"map_int32_int64,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapStringMessage  map[string]*FieldTestMessage_Message  `protobuf:"bytes,501,rep,name=map_string_message,json=mapStringMessage,proto3" json:"map_string_message,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapStringMessage2 map[string]*FieldTestMessage_Message2 `protobuf:"bytes,502,rep,name=map_string_message2,json=mapStringMessage2,proto3" json:"map_string_message2,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MapFixed64Enum    map[uint64]FieldTestMessage_Enum      `protobuf:"bytes,503,rep,name=map_fixed64_enum,json=mapFixed64Enum,proto3" json:"map_fixed64_enum,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum"`
}

func (m *FieldTestMessage) Reset()         { *m = FieldTestMessage{} }
func (m *FieldTestMessage) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage) ProtoMessage()    {}
func (*FieldTestMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0}
}
func (m *FieldTestMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage.Merge(m, src)
}
func (m *FieldTestMessage) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage proto.InternalMessageInfo

func (m *FieldTestMessage) GetOptionalBool() bool {
	if m != nil {
		return m.OptionalBool
	}
	return false
}

func (m *FieldTestMessage) GetOptionalEnum() FieldTestMessage_Enum {
	if m != nil {
		return m.OptionalEnum
	}
	return FieldTestMessage_ZERO
}

func (m *FieldTestMessage) GetOptionalInt32() int32 {
	if m != nil {
		return m.OptionalInt32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSint32() int32 {
	if m != nil {
		return m.OptionalSint32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalUint32() uint32 {
	if m != nil {
		return m.OptionalUint32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalInt64() int64 {
	if m != nil {
		return m.OptionalInt64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSint64() int64 {
	if m != nil {
		return m.OptionalSint64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalUint64() uint64 {
	if m != nil {
		return m.OptionalUint64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSfixed32() int32 {
	if m != nil {
		return m.OptionalSfixed32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFixed32() uint32 {
	if m != nil {
		return m.OptionalFixed32
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFloat() float32 {
	if m != nil {
		return m.OptionalFloat
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalSfixed64() int64 {
	if m != nil {
		return m.OptionalSfixed64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalFixed64() uint64 {
	if m != nil {
		return m.OptionalFixed64
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalDouble() float64 {
	if m != nil {
		return m.OptionalDouble
	}
	return 0
}

func (m *FieldTestMessage) GetOptionalString() string {
	if m != nil {
		return m.OptionalString
	}
	return ""
}

func (m *FieldTestMessage) GetOptionalBytes() []byte {
	if m != nil {
		return m.OptionalBytes
	}
	return nil
}

func (m *FieldTestMessage) GetOptional_Message() *FieldTestMessage_Message {
	if m != nil {
		return m.Optional_Message
	}
	return nil
}

func (m *FieldTestMessage) GetOptional_Message2() *FieldTestMessage_Message2 {
	if m != nil {
		return m.Optional_Message2
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedBool() []bool {
	if m != nil {
		return m.RepeatedBool
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedEnum() []FieldTestMessage_Enum {
	if m != nil {
		return m.RepeatedEnum
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedInt32() []int32 {
	if m != nil {
		return m.RepeatedInt32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSint32() []int32 {
	if m != nil {
		return m.RepeatedSint32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedUint32() []uint32 {
	if m != nil {
		return m.RepeatedUint32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedInt64() []int64 {
	if m != nil {
		return m.RepeatedInt64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSint64() []int64 {
	if m != nil {
		return m.RepeatedSint64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedUint64() []uint64 {
	if m != nil {
		return m.RepeatedUint64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSfixed32() []int32 {
	if m != nil {
		return m.RepeatedSfixed32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFixed32() []uint32 {
	if m != nil {
		return m.RepeatedFixed32
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFloat() []float32 {
	if m != nil {
		return m.RepeatedFloat
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedSfixed64() []int64 {
	if m != nil {
		return m.RepeatedSfixed64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedFixed64() []uint64 {
	if m != nil {
		return m.RepeatedFixed64
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedDouble() []float64 {
	if m != nil {
		return m.RepeatedDouble
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedString() []string {
	if m != nil {
		return m.RepeatedString
	}
	return nil
}

func (m *FieldTestMessage) GetRepeatedBytes() [][]byte {
	if m != nil {
		return m.RepeatedBytes
	}
	return nil
}

func (m *FieldTestMessage) GetRepeated_Message() []*FieldTestMessage_Message {
	if m != nil {
		return m.Repeated_Message
	}
	return nil
}

func (m *FieldTestMessage) GetRepeated_Message2() []*FieldTestMessage_Message2 {
	if m != nil {
		return m.Repeated_Message2
	}
	return nil
}

func (m *FieldTestMessage) GetMapBool() map[int32]bool {
	if m != nil {
		return m.MapBool
	}
	return nil
}

func (m *FieldTestMessage) GetMapEnum() map[int32]FieldTestMessage_Enum {
	if m != nil {
		return m.MapEnum
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt32() map[int32]int32 {
	if m != nil {
		return m.MapInt32
	}
	return nil
}

func (m *FieldTestMessage) GetMapSint32() map[int32]int32 {
	if m != nil {
		return m.MapSint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapUint32() map[uint32]uint32 {
	if m != nil {
		return m.MapUint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt64() map[int64]int64 {
	if m != nil {
		return m.MapInt64
	}
	return nil
}

func (m *FieldTestMessage) GetMapSint64() map[int64]int64 {
	if m != nil {
		return m.MapSint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapUint64() map[uint64]uint64 {
	if m != nil {
		return m.MapUint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapSfixed32() map[int32]int32 {
	if m != nil {
		return m.MapSfixed32
	}
	return nil
}

func (m *FieldTestMessage) GetMapFixed32() map[uint32]uint32 {
	if m != nil {
		return m.MapFixed32
	}
	return nil
}

func (m *FieldTestMessage) GetMapFloat() map[int32]float32 {
	if m != nil {
		return m.MapFloat
	}
	return nil
}

func (m *FieldTestMessage) GetMapSfixed64() map[int32]int64 {
	if m != nil {
		return m.MapSfixed64
	}
	return nil
}

func (m *FieldTestMessage) GetMapFixed64() map[int32]uint64 {
	if m != nil {
		return m.MapFixed64
	}
	return nil
}

func (m *FieldTestMessage) GetMapDouble() map[int32]float64 {
	if m != nil {
		return m.MapDouble
	}
	return nil
}

func (m *FieldTestMessage) GetMapString() map[int32]string {
	if m != nil {
		return m.MapString
	}
	return nil
}

func (m *FieldTestMessage) GetMapBytes() map[int32][]byte {
	if m != nil {
		return m.MapBytes
	}
	return nil
}

func (m *FieldTestMessage) GetMap_Message() map[int32]*FieldTestMessage_Message {
	if m != nil {
		return m.Map_Message
	}
	return nil
}

func (m *FieldTestMessage) GetMap_Message2() map[int32]*FieldTestMessage_Message2 {
	if m != nil {
		return m.Map_Message2
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyInt32() map[int32]int32 {
	if m != nil {
		return m.MapKeyInt32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeySint32() map[int32]int32 {
	if m != nil {
		return m.MapKeySint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyUint32() map[uint32]int32 {
	if m != nil {
		return m.MapKeyUint32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyInt64() map[int64]int32 {
	if m != nil {
		return m.MapKeyInt64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeySint64() map[int64]int32 {
	if m != nil {
		return m.MapKeySint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyUint64() map[uint64]int32 {
	if m != nil {
		return m.MapKeyUint64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeySfixed32() map[int32]int32 {
	if m != nil {
		return m.MapKeySfixed32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyFixed32() map[uint32]int32 {
	if m != nil {
		return m.MapKeyFixed32
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeySfixed64() map[int64]int32 {
	if m != nil {
		return m.MapKeySfixed64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyFixed64() map[uint64]int32 {
	if m != nil {
		return m.MapKeyFixed64
	}
	return nil
}

func (m *FieldTestMessage) GetMapKeyString() map[string]int32 {
	if m != nil {
		return m.MapKeyString
	}
	return nil
}

func (m *FieldTestMessage) GetMapInt32Int64() map[int32]int64 {
	if m != nil {
		return m.MapInt32Int64
	}
	return nil
}

func (m *FieldTestMessage) GetMapStringMessage() map[string]*FieldTestMessage_Message {
	if m != nil {
		return m.MapStringMessage
	}
	return nil
}

func (m *FieldTestMessage) GetMapStringMessage2() map[string]*FieldTestMessage_Message2 {
	if m != nil {
		return m.MapStringMessage2
	}
	return nil
}

func (m *FieldTestMessage) GetMapFixed64Enum() map[uint64]FieldTestMessage_Enum {
	if m != nil {
		return m.MapFixed64Enum
	}
	return nil
}

type FieldTestMessage_Message struct {
}

func (m *FieldTestMessage_Message) Reset()         { *m = FieldTestMessage_Message{} }
func (m *FieldTestMessage_Message) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage_Message) ProtoMessage()    {}
func (*FieldTestMessage_Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 33}
}
func (m *FieldTestMessage_Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage_Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage_Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage_Message.Merge(m, src)
}
func (m *FieldTestMessage_Message) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage_Message) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage_Message.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage_Message proto.InternalMessageInfo

type FieldTestMessage_Message2 struct {
	Bool bool                  `protobuf:"varint,1,opt,name=bool,proto3" json:"bool,omitempty"`
	Enum FieldTestMessage_Enum `protobuf:"varint,2,opt,name=enum,proto3,enum=goproto.protoc.proto3.FieldTestMessage_Enum" json:"enum,omitempty"`
}

func (m *FieldTestMessage_Message2) Reset()         { *m = FieldTestMessage_Message2{} }
func (m *FieldTestMessage_Message2) String() string { return proto.CompactTextString(m) }
func (*FieldTestMessage_Message2) ProtoMessage()    {}
func (*FieldTestMessage_Message2) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{0, 34}
}
func (m *FieldTestMessage_Message2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldTestMessage_Message2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldTestMessage_Message2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldTestMessage_Message2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldTestMessage_Message2.Merge(m, src)
}
func (m *FieldTestMessage_Message2) XXX_Size() int {
	return m.Size()
}
func (m *FieldTestMessage_Message2) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldTestMessage_Message2.DiscardUnknown(m)
}

var xxx_messageInfo_FieldTestMessage_Message2 proto.InternalMessageInfo

func (m *FieldTestMessage_Message2) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func (m *FieldTestMessage_Message2) GetEnum() FieldTestMessage_Enum {
	if m != nil {
		return m.Enum
	}
	return FieldTestMessage_ZERO
}

type Example struct {
	Filed int32 `protobuf:"varint,1,opt,name=filed,proto3" json:"filed,omitempty"`
}

func (m *Example) Reset()         { *m = Example{} }
func (m *Example) String() string { return proto.CompactTextString(m) }
func (*Example) ProtoMessage()    {}
func (*Example) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39ad626ec0e575e, []int{1}
}
func (m *Example) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Example) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Example.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Example) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Example.Merge(m, src)
}
func (m *Example) XXX_Size() int {
	return m.Size()
}
func (m *Example) XXX_DiscardUnknown() {
	xxx_messageInfo_Example.DiscardUnknown(m)
}

var xxx_messageInfo_Example proto.InternalMessageInfo

func (m *Example) GetFiled() int32 {
	if m != nil {
		return m.Filed
	}
	return 0
}

func init() {
	proto.RegisterEnum("goproto.protoc.proto3.Enum", Enum_name, Enum_value)
	proto.RegisterEnum("goproto.protoc.proto3.FieldTestMessage_Enum", FieldTestMessage_Enum_name, FieldTestMessage_Enum_value)
	proto.RegisterType((*FieldTestMessage)(nil), "goproto.protoc.proto3.FieldTestMessage")
	proto.RegisterMapType((map[int32]bool)(nil), "goproto.protoc.proto3.FieldTestMessage.MapBoolEntry")
	proto.RegisterMapType((map[int32][]byte)(nil), "goproto.protoc.proto3.FieldTestMessage.MapBytesEntry")
	proto.RegisterMapType((map[int32]float64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapDoubleEntry")
	proto.RegisterMapType((map[int32]FieldTestMessage_Enum)(nil), "goproto.protoc.proto3.FieldTestMessage.MapEnumEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapFixed32Entry")
	proto.RegisterMapType((map[int32]uint64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapFixed64Entry")
	proto.RegisterMapType((map[uint64]FieldTestMessage_Enum)(nil), "goproto.protoc.proto3.FieldTestMessage.MapFixed64EnumEntry")
	proto.RegisterMapType((map[int32]float32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapFloatEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt32Entry")
	proto.RegisterMapType((map[int32]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt32Int64Entry")
	proto.RegisterMapType((map[int64]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapInt64Entry")
	proto.RegisterMapType((map[uint32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyFixed32Entry")
	proto.RegisterMapType((map[uint64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyFixed64Entry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyInt32Entry")
	proto.RegisterMapType((map[int64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyInt64Entry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeySfixed32Entry")
	proto.RegisterMapType((map[int64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeySfixed64Entry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeySint32Entry")
	proto.RegisterMapType((map[int64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeySint64Entry")
	proto.RegisterMapType((map[string]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyStringEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyUint32Entry")
	proto.RegisterMapType((map[uint64]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapKeyUint64Entry")
	proto.RegisterMapType((map[int32]*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.MapMessage2Entry")
	proto.RegisterMapType((map[int32]*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.MapMessageEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapSfixed32Entry")
	proto.RegisterMapType((map[int32]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapSfixed64Entry")
	proto.RegisterMapType((map[int32]int32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapSint32Entry")
	proto.RegisterMapType((map[int64]int64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapSint64Entry")
	proto.RegisterMapType((map[int32]string)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringEntry")
	proto.RegisterMapType((map[string]*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringMessage2Entry")
	proto.RegisterMapType((map[string]*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.MapStringMessageEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "goproto.protoc.proto3.FieldTestMessage.MapUint32Entry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "goproto.protoc.proto3.FieldTestMessage.MapUint64Entry")
	proto.RegisterType((*FieldTestMessage_Message)(nil), "goproto.protoc.proto3.FieldTestMessage.Message")
	proto.RegisterType((*FieldTestMessage_Message2)(nil), "goproto.protoc.proto3.FieldTestMessage.Message2")
	proto.RegisterType((*Example)(nil), "goproto.protoc.proto3.Example")
}

func init() { proto.RegisterFile("fields.proto", fileDescriptor_d39ad626ec0e575e) }

var fileDescriptor_d39ad626ec0e575e = []byte{
	// 1644 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x59, 0x6f, 0x1c, 0xc5,
	0x16, 0x76, 0xcd, 0xe2, 0x99, 0xa9, 0xcc, 0xd2, 0x53, 0xb9, 0xb9, 0x2a, 0xe5, 0xc1, 0xb7, 0xe5,
	0x7b, 0x2f, 0x34, 0x21, 0x72, 0xd0, 0xa4, 0x28, 0x82, 0x43, 0x42, 0xb0, 0xb0, 0x25, 0x84, 0x20,
	0xd0, 0x89, 0x41, 0x04, 0x42, 0x32, 0x8e, 0xdb, 0x61, 0x94, 0xd9, 0x64, 0x8f, 0xa3, 0xf8, 0x5f,
	0x20, 0xb1, 0x23, 0x96, 0x5f, 0xc0, 0xbe, 0xaf, 0xcf, 0xec, 0x84, 0x3d, 0xf0, 0x84, 0x92, 0xbf,
	0xc0, 0xf2, 0x8a, 0xaa, 0xab, 0xaa, 0xab, 0xaa, 0xbb, 0xcc, 0x4c, 0x37, 0x79, 0x9a, 0xe9, 0xca,
	0x39, 0xdf, 0x57, 0xe7, 0xd4, 0xf9, 0xbe, 0xae, 0x8c, 0x61, 0x75, 0xad, 0x13, 0x74, 0x57, 0x37,
	0xe6, 0x86, 0xeb, 0x83, 0xd1, 0x00, 0xed, 0x3a, 0x3b, 0x08, 0xbf, 0xf0, 0xc7, 0x33, 0xfc, 0x63,
	0xff, 0xec, 0x0b, 0xf3, 0xd0, 0x59, 0x62, 0x71, 0xc7, 0x83, 0x8d, 0xd1, 0x5d, 0xc1, 0xc6, 0x46,
	0xfb, 0x6c, 0x80, 0xfe, 0x0b, 0x6b, 0x83, 0xe1, 0xa8, 0x33, 0xe8, 0xb7, 0xbb, 0xa7, 0x56, 0x06,
	0x83, 0x2e, 0x06, 0x2e, 0xf0, 0xca, 0x7e, 0x55, 0x2e, 0x2e, 0x0c, 0x06, 0x5d, 0x74, 0xaf, 0x16,
	0x14, 0xf4, 0x37, 0x7b, 0x38, 0xe7, 0x02, 0xaf, 0xde, 0xda, 0x3b, 0x67, 0x25, 0x9a, 0x8b, 0x93,
	0xcc, 0x2d, 0xf6, 0x37, 0x7b, 0x0a, 0x92, 0x3d, 0xa1, 0xff, 0xc3, 0x7a, 0x04, 0xd9, 0xe9, 0x8f,
	0xf6, 0xb7, 0x70, 0xde, 0x05, 0x5e, 0xd1, 0x8f, 0x88, 0xee, 0x60, 0x8b, 0xe8, 0x5a, 0xd8, 0x88,
	0xc2, 0x36, 0x78, 0x5c, 0xc1, 0x05, 0x5e, 0xd3, 0x8f, 0xb2, 0x8f, 0x75, 0x12, 0x81, 0x9b, 0x3c,
	0xb0, 0xe8, 0x02, 0xaf, 0xa6, 0x02, 0x97, 0x79, 0x60, 0x8c, 0x98, 0x12, 0x3c, 0xed, 0x02, 0x2f,
	0x6f, 0x10, 0x53, 0x92, 0x20, 0xa6, 0x04, 0x97, 0x5c, 0xe0, 0x21, 0x93, 0x38, 0x16, 0xb8, 0xc9,
	0x03, 0xcb, 0x2e, 0xf0, 0x0a, 0x26, 0x31, 0x25, 0xe8, 0x7a, 0xd8, 0x54, 0x88, 0x6b, 0x9d, 0x0b,
	0xc1, 0xea, 0xfe, 0x16, 0xae, 0xb8, 0xc0, 0x6b, 0xf8, 0x4e, 0x84, 0x29, 0xd6, 0xd1, 0x75, 0x30,
	0x5a, 0x3b, 0x25, 0x63, 0xa1, 0x0b, 0xbc, 0x92, 0x1f, 0xb1, 0x2d, 0x89, 0x50, 0xbd, 0xa0, 0xb5,
	0xee, 0xa0, 0x3d, 0xc2, 0x3b, 0x5c, 0xe0, 0xe5, 0x54, 0x41, 0x4b, 0x6c, 0xd1, 0x42, 0x4f, 0x09,
	0xae, 0xba, 0xc0, 0x73, 0xe2, 0xf4, 0x94, 0x24, 0xe9, 0x29, 0xc1, 0x35, 0x17, 0x78, 0xd3, 0x31,
	0xfa, 0x58, 0xfd, 0xab, 0x83, 0xcd, 0x95, 0x6e, 0x80, 0xeb, 0x2e, 0xf0, 0x80, 0xaa, 0xff, 0xf6,
	0x70, 0xd5, 0xec, 0xe8, 0x68, 0xbd, 0xd3, 0x3f, 0x8b, 0x1b, 0x2e, 0xf0, 0x2a, 0x5a, 0x47, 0xc3,
	0x55, 0xa3, 0xa0, 0x95, 0xad, 0x51, 0xb0, 0x81, 0x1d, 0x17, 0x78, 0x55, 0x55, 0xd0, 0x02, 0x5b,
	0x44, 0x27, 0xb4, 0x3d, 0x8a, 0x41, 0xc3, 0x4d, 0x17, 0x78, 0x3b, 0x5a, 0xfb, 0x26, 0x9d, 0x4b,
	0xf1, 0xa9, 0x8a, 0x92, 0xaa, 0x38, 0xa9, 0x35, 0x4b, 0xac, 0xb5, 0x30, 0x0a, 0xc1, 0x6f, 0x48,
	0x09, 0xde, 0x52, 0xed, 0x95, 0x2b, 0xe8, 0x7f, 0xb0, 0xb6, 0x1e, 0x0c, 0x83, 0xf6, 0x28, 0x58,
	0xe5, 0xa2, 0xfb, 0x14, 0xb8, 0x79, 0xa6, 0x3a, 0xb9, 0x1a, 0xaa, 0xce, 0xd7, 0xa2, 0x42, 0xd5,
	0x7d, 0xc6, 0xa2, 0x52, 0xcb, 0x4e, 0x62, 0x84, 0xb2, 0xbb, 0x06, 0xd6, 0x23, 0x4c, 0xae, 0x92,
	0xcf, 0x19, 0x68, 0xd1, 0x8f, 0xa8, 0xb8, 0xee, 0x3c, 0xd8, 0x88, 0xe2, 0x84, 0xee, 0xbe, 0x60,
	0x81, 0x4d, 0x3f, 0xca, 0x17, 0xc2, 0xd3, 0x23, 0x85, 0xf0, 0xbe, 0x64, 0x91, 0x35, 0x15, 0x29,
	0x94, 0x17, 0xe3, 0xa6, 0x04, 0x7f, 0xc5, 0x02, 0xf3, 0x06, 0x37, 0x25, 0x09, 0x6e, 0x4a, 0xf0,
	0xd7, 0x2c, 0x10, 0x99, 0xdc, 0xb1, 0x48, 0xa1, 0xbd, 0x8b, 0x2c, 0xb2, 0x60, 0x72, 0x53, 0x82,
	0xf6, 0xc2, 0xa6, 0xc2, 0x94, 0x82, 0xfa, 0x86, 0xc5, 0x36, 0x7c, 0x27, 0x42, 0x95, 0xea, 0xdb,
	0x03, 0xa3, 0xb5, 0x48, 0x7d, 0xdf, 0xb2, 0xe0, 0x92, 0x1f, 0x11, 0x4a, 0xf9, 0xe9, 0x55, 0x71,
	0xf9, 0x7d, 0xc7, 0x22, 0x73, 0xaa, 0x2a, 0xae, 0xbf, 0xe4, 0x0e, 0x28, 0xc1, 0xdf, 0xb3, 0x50,
	0x27, 0xbe, 0x03, 0x4a, 0x92, 0x3b, 0xa0, 0x04, 0xff, 0xc0, 0x82, 0xa7, 0x63, 0x3b, 0x88, 0x75,
	0x41, 0x28, 0xf0, 0x47, 0x16, 0x0a, 0x54, 0x17, 0x84, 0x04, 0x8d, 0xce, 0x72, 0x09, 0xfe, 0xc4,
	0x22, 0x2b, 0x5a, 0x67, 0xb9, 0x06, 0xf5, 0xaa, 0xb8, 0x06, 0x2f, 0xb1, 0xc0, 0xaa, 0xaa, 0x8a,
	0x8b, 0xf0, 0x41, 0x6d, 0x9f, 0x52, 0x84, 0x3f, 0xb3, 0xc8, 0x2c, 0x2a, 0x94, 0x48, 0x52, 0x85,
	0x0f, 0x6b, 0x2d, 0x8b, 0x54, 0xf8, 0x0b, 0x47, 0xcf, 0x20, 0xc3, 0x18, 0x7c, 0x0b, 0xdd, 0x03,
	0xcb, 0xbd, 0xf6, 0x90, 0x2b, 0xf0, 0xa5, 0x5c, 0x08, 0x4b, 0x26, 0x86, 0x6d, 0x0f, 0x99, 0x48,
	0x17, 0xfb, 0xa3, 0xf5, 0x2d, 0xbf, 0xd4, 0xe3, 0x4f, 0x12, 0x31, 0x54, 0xeb, 0xcb, 0xe9, 0x11,
	0x99, 0x44, 0x15, 0x62, 0x28, 0xd8, 0x63, 0xb0, 0xc2, 0x10, 0xb9, 0xb0, 0x5e, 0xe1, 0x90, 0x37,
	0xa6, 0x80, 0x0c, 0xe5, 0xcc, 0x31, 0xd9, 0xd6, 0xb8, 0xba, 0xef, 0x83, 0x90, 0x81, 0x0a, 0x61,
	0xbf, 0xca, 0x51, 0x69, 0x0a, 0x54, 0xae, 0x7d, 0x0e, 0xcb, 0xf6, 0x27, 0xbc, 0x40, 0xe0, 0x0a,
	0x1b, 0x78, 0x2d, 0x3d, 0xee, 0x72, 0x0c, 0x57, 0x38, 0x87, 0x6a, 0x02, 0x25, 0xf8, 0xf5, 0x4c,
	0x4d, 0xa0, 0xc4, 0x68, 0x02, 0x25, 0x7a, 0x13, 0x28, 0xc1, 0x6f, 0x64, 0x6b, 0x82, 0x84, 0x95,
	0x4d, 0x50, 0xb8, 0xc2, 0x8f, 0xde, 0xcc, 0xd6, 0x04, 0x1d, 0x57, 0x58, 0xd8, 0x43, 0xb0, 0x1a,
	0xee, 0x57, 0x1a, 0xd2, 0x5b, 0x1c, 0xf9, 0x40, 0x9a, 0x1d, 0x8b, 0x5c, 0x8e, 0xbd, 0xa3, 0xa7,
	0x56, 0xd0, 0x03, 0x90, 0x3d, 0x46, 0x6e, 0xf7, 0x36, 0x07, 0xbf, 0x29, 0x05, 0xf8, 0x92, 0x8e,
	0xcd, 0x5a, 0x20, 0x1d, 0x52, 0x9c, 0x1e, 0x37, 0xc7, 0x77, 0xd2, 0x9f, 0x5e, 0xe8, 0x9f, 0xea,
	0xf4, 0xb8, 0x9d, 0x1a, 0xdd, 0xa0, 0x04, 0xbf, 0x9b, 0xb5, 0x1b, 0xb2, 0xd3, 0xaa, 0x1b, 0x94,
	0x18, 0xdd, 0xa0, 0x04, 0xbf, 0x97, 0xb1, 0x1b, 0x12, 0x3b, 0xea, 0x86, 0x1a, 0x0f, 0x61, 0xd4,
	0xef, 0xa7, 0x1f, 0x0f, 0xee, 0xe5, 0x6a, 0x3c, 0x84, 0xb7, 0xcb, 0x71, 0xe6, 0xb6, 0xfe, 0x41,
	0x86, 0x71, 0x0e, 0x33, 0xb5, 0x71, 0xe6, 0x6f, 0x02, 0x71, 0x7a, 0xfc, 0x25, 0xf0, 0x61, 0xfa,
	0xd3, 0x0b, 0xdf, 0x13, 0xea, 0xf4, 0xf8, 0x6b, 0x43, 0xf4, 0x57, 0xbe, 0x31, 0x3e, 0x4a, 0xdf,
	0x5f, 0xf1, 0x55, 0xf5, 0x57, 0xbe, 0x34, 0xc4, 0x60, 0x44, 0xef, 0x8b, 0x8f, 0xd3, 0x0f, 0x86,
	0xcc, 0x55, 0x83, 0x11, 0xbd, 0x32, 0x4e, 0xc2, 0x1a, 0x43, 0x3f, 0x17, 0x6c, 0x09, 0x4b, 0x7e,
	0x2c, 0x9f, 0x1a, 0xfe, 0xce, 0x60, 0x4b, 0x73, 0x65, 0x06, 0x2f, 0x57, 0xd0, 0x69, 0x58, 0x97,
	0xf0, 0xc2, 0x9c, 0x1f, 0xe7, 0xf8, 0x37, 0xa7, 0xc3, 0xd7, 0xfd, 0xb9, 0xda, 0xd3, 0x96, 0x74,
	0x06, 0x61, 0xd3, 0x4f, 0x64, 0x62, 0x58, 0x4e, 0x32, 0x08, 0xb3, 0x36, 0x5b, 0x44, 0x09, 0x7e,
	0x32, 0x6b, 0x8b, 0x74, 0x69, 0xca, 0x95, 0x78, 0x8b, 0x28, 0xc1, 0x4f, 0x65, 0x6e, 0x91, 0x24,
	0xd0, 0x5a, 0x64, 0x32, 0x08, 0x13, 0x7f, 0x3a, 0x73, 0x8b, 0x62, 0x0c, 0xc2, 0xca, 0xd7, 0xa0,
	0x13, 0xd5, 0x20, 0x1d, 0xf7, 0x19, 0xce, 0x71, 0x30, 0x65, 0x15, 0x86, 0xa3, 0xd7, 0x7b, 0xc6,
	0x22, 0x3a, 0x03, 0x1b, 0x92, 0x47, 0xd2, 0x3c, 0xcb, 0x69, 0xe6, 0xd3, 0xd1, 0x18, 0xde, 0x5e,
	0xeb, 0xe9, 0x6b, 0xc9, 0x62, 0x28, 0xc1, 0xcf, 0xfd, 0x83, 0x62, 0x64, 0xcb, 0x8c, 0x62, 0x28,
	0x49, 0x14, 0x43, 0x09, 0x7e, 0x3e, 0x7b, 0x31, 0x92, 0x45, 0x2f, 0x26, 0x36, 0x5d, 0xdc, 0x49,
	0x5f, 0xcc, 0x36, 0x5d, 0x9a, 0x99, 0xca, 0xe9, 0xe2, 0x7e, 0x2a, 0xca, 0x08, 0xb5, 0x22, 0x04,
	0xf2, 0x5b, 0xfa, 0x32, 0x42, 0xbb, 0xd0, 0x24, 0x52, 0xeb, 0xe9, 0x6b, 0xa8, 0x0b, 0x91, 0x7a,
	0x19, 0x9c, 0xea, 0x09, 0x9b, 0xfd, 0x9d, 0xf3, 0x1c, 0x4a, 0xfd, 0x52, 0x30, 0xcc, 0xd6, 0xe9,
	0xc5, 0x96, 0xd1, 0x00, 0xee, 0x4c, 0xb2, 0xb5, 0xf0, 0x1f, 0x9c, 0xee, 0x70, 0x56, 0x3a, 0x31,
	0x6e, 0xcd, 0x38, 0x5f, 0x34, 0x72, 0x62, 0x0c, 0xf8, 0x75, 0xfb, 0xcf, 0xf4, 0x23, 0x17, 0x0d,
	0x82, 0xbc, 0x75, 0xd7, 0x7b, 0xc6, 0xe2, 0xee, 0x79, 0x58, 0xd5, 0xef, 0xf9, 0xc8, 0x81, 0xf9,
	0x73, 0xc1, 0x56, 0xf8, 0x13, 0x59, 0xd1, 0x67, 0x5f, 0xd1, 0xbf, 0x60, 0xf1, 0x7c, 0xbb, 0xbb,
	0x19, 0x84, 0xbf, 0x88, 0x95, 0x7d, 0xfe, 0x30, 0x9f, 0x3b, 0x00, 0x76, 0x3f, 0x12, 0xe6, 0x46,
	0xd8, 0x96, 0xdc, 0x05, 0x3d, 0x37, 0xed, 0x7f, 0xeb, 0x35, 0xa6, 0x83, 0xb0, 0x66, 0x5c, 0xf4,
	0xc7, 0x6d, 0xb3, 0xa8, 0x27, 0xdf, 0x02, 0xeb, 0xe6, 0x7d, 0x5e, 0xcf, 0x6e, 0x5a, 0xb2, 0x9b,
	0xc9, 0xec, 0x65, 0x7b, 0x76, 0xcd, 0x92, 0x5d, 0xb3, 0x6e, 0x5c, 0x4c, 0xb1, 0x9e, 0x9c, 0xb7,
	0x24, 0xe7, 0xed, 0x1b, 0xb7, 0x64, 0x23, 0x4b, 0x36, 0xb2, 0x6f, 0xdc, 0x92, 0x5d, 0xb0, 0x64,
	0x17, 0xf4, 0xec, 0xc3, 0xd0, 0x89, 0xdf, 0xa6, 0xf5, 0xfc, 0x86, 0x25, 0xbf, 0xa1, 0xe7, 0x1f,
	0x82, 0x8d, 0xd8, 0x85, 0x59, 0x4f, 0x2f, 0x59, 0xd2, 0x4b, 0xc9, 0xbe, 0xa9, 0x6b, 0xf1, 0xb8,
	0x03, 0xcf, 0x6d, 0xb7, 0x77, 0x4b, 0xed, 0xb6, 0x7c, 0x67, 0x9b, 0xbd, 0x4f, 0x98, 0x3e, 0x9d,
	0x6c, 0xbc, 0x76, 0x87, 0x1d, 0x97, 0x0d, 0x2c, 0x87, 0xae, 0xcc, 0x75, 0x5c, 0x76, 0x25, 0xd9,
	0x37, 0x75, 0x21, 0x1d, 0x97, 0x5c, 0xd5, 0x93, 0xfb, 0x61, 0xdd, 0xba, 0x13, 0x5a, 0xd2, 0x17,
	0xf5, 0xf4, 0x0c, 0x3f, 0x81, 0x68, 0x7c, 0xc3, 0xf0, 0x9c, 0x0c, 0x2b, 0xb4, 0x10, 0x2e, 0x99,
	0x84, 0xe9, 0x7f, 0x15, 0x49, 0x4c, 0x86, 0x71, 0x3b, 0x4d, 0x65, 0x25, 0xb7, 0xc2, 0x66, 0xe2,
	0xf6, 0x39, 0xce, 0x4d, 0xec, 0x00, 0x29, 0x0c, 0xa5, 0xb8, 0x5d, 0x05, 0x13, 0x7a, 0xca, 0xf6,
	0x15, 0x4c, 0x68, 0x2b, 0xdb, 0x57, 0x30, 0xa1, 0xb3, 0x18, 0x00, 0xb7, 0xc1, 0x9d, 0x96, 0x8b,
	0xdd, 0x38, 0x73, 0x31, 0x20, 0x8e, 0x40, 0x94, 0xbc, 0xb4, 0x8d, 0xf3, 0x97, 0xbf, 0xdb, 0x84,
	0xa5, 0x0e, 0x27, 0xdd, 0x26, 0x2c, 0x08, 0xd3, 0x93, 0x9f, 0x85, 0x5d, 0xed, 0x95, 0xc9, 0xb6,
	0x10, 0xbb, 0x28, 0x8d, 0x1b, 0x68, 0xe3, 0x15, 0x33, 0x82, 0xbb, 0xac, 0x57, 0x20, 0xcb, 0x36,
	0xae, 0xa2, 0xf0, 0xcf, 0xc3, 0x7f, 0xdb, 0x6f, 0x42, 0x16, 0xda, 0xab, 0x29, 0xff, 0x41, 0x78,
	0xea, 0xf1, 0x3b, 0x91, 0xe5, 0xcc, 0xae, 0xd6, 0xbd, 0xa5, 0x02, 0x4b, 0xe2, 0x9f, 0x76, 0x9f,
	0x86, 0xe5, 0xe8, 0x72, 0x87, 0x60, 0x41, 0xfb, 0x43, 0x64, 0xf8, 0x1d, 0x1d, 0x81, 0x85, 0xcc,
	0x7f, 0x77, 0x0c, 0x33, 0x67, 0x67, 0x61, 0x21, 0xfc, 0x3d, 0xb5, 0x0c, 0x0b, 0x27, 0x16, 0xfd,
	0xa3, 0xce, 0x14, 0x2a, 0xc1, 0xfc, 0xd1, 0xbb, 0x17, 0x1d, 0xc0, 0xbe, 0x1c, 0xbf, 0xff, 0xa8,
	0x93, 0x9b, 0xfd, 0x0f, 0x2c, 0x2d, 0x5e, 0x68, 0xf7, 0x86, 0xdd, 0x80, 0x0d, 0xc5, 0x5a, 0xa7,
	0x1b, 0xac, 0x8a, 0x41, 0xe1, 0x0f, 0x7b, 0x26, 0x00, 0x59, 0x98, 0xfd, 0xe4, 0xf2, 0x0c, 0xb8,
	0x78, 0x79, 0x06, 0xfc, 0x7a, 0x79, 0x06, 0x3c, 0x7a, 0x65, 0x66, 0xea, 0xe2, 0x95, 0x99, 0xa9,
	0x4b, 0x57, 0x66, 0xa6, 0x4e, 0x94, 0xe7, 0xf6, 0xf1, 0x8d, 0xae, 0x4c, 0xf3, 0xcf, 0xbf, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xf4, 0xdf, 0x1d, 0xee, 0xb7, 0x1d, 0x00, 0x00,
}

func (m *FieldTestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MapFixed64Enum) > 0 {
		for k := range m.MapFixed64Enum {
			v := m.MapFixed64Enum[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1f
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapStringMessage2) > 0 {
		for k := range m.MapStringMessage2 {
			v := m.MapStringMessage2[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1f
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapStringMessage) > 0 {
		for k := range m.MapStringMessage {
			v := m.MapStringMessage[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1f
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapInt32Int64) > 0 {
		for k := range m.MapInt32Int64 {
			v := m.MapInt32Int64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1f
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapKeyString) > 0 {
		for k := range m.MapKeyString {
			v := m.MapKeyString[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFields(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapKeyFixed64) > 0 {
		for k := range m.MapKeyFixed64 {
			v := m.MapKeyFixed64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapKeySfixed64) > 0 {
		for k := range m.MapKeySfixed64 {
			v := m.MapKeySfixed64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(k))
			i--
			dAtA[i] = 0x9
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapKeyFixed32) > 0 {
		for k := range m.MapKeyFixed32 {
			v := m.MapKeyFixed32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapKeySfixed32) > 0 {
		for k := range m.MapKeySfixed32 {
			v := m.MapKeySfixed32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapKeyUint64) > 0 {
		for k := range m.MapKeyUint64 {
			v := m.MapKeyUint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapKeySint64) > 0 {
		for k := range m.MapKeySint64 {
			v := m.MapKeySint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapKeyInt64) > 0 {
		for k := range m.MapKeyInt64 {
			v := m.MapKeyInt64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapKeyUint32) > 0 {
		for k := range m.MapKeyUint32 {
			v := m.MapKeyUint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapKeySint32) > 0 {
		for k := range m.MapKeySint32 {
			v := m.MapKeySint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapKeyInt32) > 0 {
		for k := range m.MapKeyInt32 {
			v := m.MapKeyInt32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x19
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Map_Message2) > 0 {
		for k := range m.Map_Message2 {
			v := m.Map_Message2[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.Map_Message) > 0 {
		for k := range m.Map_Message {
			v := m.Map_Message[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFields(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.MapBytes) > 0 {
		for k := range m.MapBytes {
			v := m.MapBytes[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFields(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.MapString) > 0 {
		for k := range m.MapString {
			v := m.MapString[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintFields(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.MapDouble) > 0 {
		for k := range m.MapDouble {
			v := m.MapDouble[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.MapFixed64) > 0 {
		for k := range m.MapFixed64 {
			v := m.MapFixed64[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.MapSfixed64) > 0 {
		for k := range m.MapSfixed64 {
			v := m.MapSfixed64[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(v))
			i--
			dAtA[i] = 0x11
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.MapFloat) > 0 {
		for k := range m.MapFloat {
			v := m.MapFloat[k]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MapFixed32) > 0 {
		for k := range m.MapFixed32 {
			v := m.MapFixed32[k]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MapSfixed32) > 0 {
		for k := range m.MapSfixed32 {
			v := m.MapSfixed32[k]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(v))
			i--
			dAtA[i] = 0x15
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.MapUint64) > 0 {
		for k := range m.MapUint64 {
			v := m.MapUint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.MapSint64) > 0 {
		for k := range m.MapSint64 {
			v := m.MapSint64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64((uint64(k)<<1)^uint64((k>>63))))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.MapInt64) > 0 {
		for k := range m.MapInt64 {
			v := m.MapInt64[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MapUint32) > 0 {
		for k := range m.MapUint32 {
			v := m.MapUint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MapSint32) > 0 {
		for k := range m.MapSint32 {
			v := m.MapSint32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64((uint32(k)<<1)^uint32((k>>31))))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x13
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.MapInt32) > 0 {
		for k := range m.MapInt32 {
			v := m.MapInt32[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
			i--
			dAtA[i] = 0xfa
		}
	}
	if len(m.MapEnum) > 0 {
		for k := range m.MapEnum {
			v := m.MapEnum[k]
			baseI := i
			i = encodeVarintFields(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.MapBool) > 0 {
		for k := range m.MapBool {
			v := m.MapBool[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintFields(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFields(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.Repeated_Message2) > 0 {
		for iNdEx := len(m.Repeated_Message2) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Repeated_Message2[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Repeated_Message) > 0 {
		for iNdEx := len(m.Repeated_Message) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Repeated_Message[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFields(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for iNdEx := len(m.RepeatedBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedBytes[iNdEx])
			copy(dAtA[i:], m.RepeatedBytes[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedBytes[iNdEx])))
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.RepeatedString) > 0 {
		for iNdEx := len(m.RepeatedString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RepeatedString[iNdEx])
			copy(dAtA[i:], m.RepeatedString[iNdEx])
			i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedString[iNdEx])))
			i--
			dAtA[i] = 0xd
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.RepeatedDouble) > 0 {
		for iNdEx := len(m.RepeatedDouble) - 1; iNdEx >= 0; iNdEx-- {
			f5 := math.Float64bits(float64(m.RepeatedDouble[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f5))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedDouble)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xb2
	}
	if len(m.RepeatedFixed64) > 0 {
		for iNdEx := len(m.RepeatedFixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedFixed64[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFixed64)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RepeatedSfixed64) > 0 {
		for iNdEx := len(m.RepeatedSfixed64) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.RepeatedSfixed64[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedSfixed64)*8))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RepeatedFloat) > 0 {
		for iNdEx := len(m.RepeatedFloat) - 1; iNdEx >= 0; iNdEx-- {
			f6 := math.Float32bits(float32(m.RepeatedFloat[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f6))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFloat)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RepeatedFixed32) > 0 {
		for iNdEx := len(m.RepeatedFixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedFixed32[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedFixed32)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x92
	}
	if len(m.RepeatedSfixed32) > 0 {
		for iNdEx := len(m.RepeatedSfixed32) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RepeatedSfixed32[iNdEx]))
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedSfixed32)*4))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x8a
	}
	if len(m.RepeatedUint64) > 0 {
		dAtA8 := make([]byte, len(m.RepeatedUint64)*10)
		var j7 int
		for _, num := range m.RepeatedUint64 {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintFields(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x82
	}
	if len(m.RepeatedSint64) > 0 {
		var j9 int
		dAtA11 := make([]byte, len(m.RepeatedSint64)*10)
		for _, num := range m.RepeatedSint64 {
			x10 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x10 >= 1<<7 {
				dAtA11[j9] = uint8(uint64(x10)&0x7f | 0x80)
				j9++
				x10 >>= 7
			}
			dAtA11[j9] = uint8(x10)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA11[:j9])
		i = encodeVarintFields(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xfa
	}
	if len(m.RepeatedInt64) > 0 {
		dAtA13 := make([]byte, len(m.RepeatedInt64)*10)
		var j12 int
		for _, num1 := range m.RepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintFields(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RepeatedUint32) > 0 {
		dAtA15 := make([]byte, len(m.RepeatedUint32)*10)
		var j14 int
		for _, num := range m.RepeatedUint32 {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintFields(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xea
	}
	if len(m.RepeatedSint32) > 0 {
		dAtA16 := make([]byte, len(m.RepeatedSint32)*5)
		var j17 int
		for _, num := range m.RepeatedSint32 {
			x18 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x18 >= 1<<7 {
				dAtA16[j17] = uint8(uint64(x18)&0x7f | 0x80)
				j17++
				x18 >>= 7
			}
			dAtA16[j17] = uint8(x18)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA16[:j17])
		i = encodeVarintFields(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe2
	}
	if len(m.RepeatedInt32) > 0 {
		dAtA20 := make([]byte, len(m.RepeatedInt32)*10)
		var j19 int
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintFields(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xda
	}
	if len(m.RepeatedEnum) > 0 {
		dAtA22 := make([]byte, len(m.RepeatedEnum)*10)
		var j21 int
		for _, num := range m.RepeatedEnum {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintFields(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RepeatedBool) > 0 {
		for iNdEx := len(m.RepeatedBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RepeatedBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintFields(dAtA, i, uint64(len(m.RepeatedBool)))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if m.Optional_Message2 != nil {
		{
			size, err := m.Optional_Message2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFields(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Optional_Message != nil {
		{
			size, err := m.Optional_Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFields(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.OptionalBytes) > 0 {
		i -= len(m.OptionalBytes)
		copy(dAtA[i:], m.OptionalBytes)
		i = encodeVarintFields(dAtA, i, uint64(len(m.OptionalBytes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.OptionalString) > 0 {
		i -= len(m.OptionalString)
		copy(dAtA[i:], m.OptionalString)
		i = encodeVarintFields(dAtA, i, uint64(len(m.OptionalString)))
		i--
		dAtA[i] = 0x7a
	}
	if m.OptionalDouble != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionalDouble))))
		i--
		dAtA[i] = 0x71
	}
	if m.OptionalFixed64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalFixed64))
		i--
		dAtA[i] = 0x69
	}
	if m.OptionalSfixed64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OptionalSfixed64))
		i--
		dAtA[i] = 0x61
	}
	if m.OptionalFloat != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OptionalFloat))))
		i--
		dAtA[i] = 0x5d
	}
	if m.OptionalFixed32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalFixed32))
		i--
		dAtA[i] = 0x55
	}
	if m.OptionalSfixed32 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.OptionalSfixed32))
		i--
		dAtA[i] = 0x4d
	}
	if m.OptionalUint64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalUint64))
		i--
		dAtA[i] = 0x40
	}
	if m.OptionalSint64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64((uint64(m.OptionalSint64)<<1)^uint64((m.OptionalSint64>>63))))
		i--
		dAtA[i] = 0x38
	}
	if m.OptionalInt64 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalInt64))
		i--
		dAtA[i] = 0x30
	}
	if m.OptionalUint32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalUint32))
		i--
		dAtA[i] = 0x28
	}
	if m.OptionalSint32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64((uint32(m.OptionalSint32)<<1)^uint32((m.OptionalSint32>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.OptionalInt32 != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalInt32))
		i--
		dAtA[i] = 0x18
	}
	if m.OptionalEnum != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.OptionalEnum))
		i--
		dAtA[i] = 0x10
	}
	if m.OptionalBool {
		i--
		if m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldTestMessage_Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage_Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FieldTestMessage_Message2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldTestMessage_Message2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldTestMessage_Message2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enum != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.Enum))
		i--
		dAtA[i] = 0x10
	}
	if m.Bool {
		i--
		if m.Bool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Example) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Example) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Example) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Filed != 0 {
		i = encodeVarintFields(dAtA, i, uint64(m.Filed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFields(dAtA []byte, offset int, v uint64) int {
	offset -= sovFields(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FieldTestMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionalBool {
		n += 2
	}
	if m.OptionalEnum != 0 {
		n += 1 + sovFields(uint64(m.OptionalEnum))
	}
	if m.OptionalInt32 != 0 {
		n += 1 + sovFields(uint64(m.OptionalInt32))
	}
	if m.OptionalSint32 != 0 {
		n += 1 + sozFields(uint64(m.OptionalSint32))
	}
	if m.OptionalUint32 != 0 {
		n += 1 + sovFields(uint64(m.OptionalUint32))
	}
	if m.OptionalInt64 != 0 {
		n += 1 + sovFields(uint64(m.OptionalInt64))
	}
	if m.OptionalSint64 != 0 {
		n += 1 + sozFields(uint64(m.OptionalSint64))
	}
	if m.OptionalUint64 != 0 {
		n += 1 + sovFields(uint64(m.OptionalUint64))
	}
	if m.OptionalSfixed32 != 0 {
		n += 5
	}
	if m.OptionalFixed32 != 0 {
		n += 5
	}
	if m.OptionalFloat != 0 {
		n += 5
	}
	if m.OptionalSfixed64 != 0 {
		n += 9
	}
	if m.OptionalFixed64 != 0 {
		n += 9
	}
	if m.OptionalDouble != 0 {
		n += 9
	}
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sovFields(uint64(l))
	}
	l = len(m.OptionalBytes)
	if l > 0 {
		n += 2 + l + sovFields(uint64(l))
	}
	if m.Optional_Message != nil {
		l = m.Optional_Message.Size()
		n += 2 + l + sovFields(uint64(l))
	}
	if m.Optional_Message2 != nil {
		l = m.Optional_Message2.Size()
		n += 2 + l + sovFields(uint64(l))
	}
	if len(m.RepeatedBool) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedBool))) + len(m.RepeatedBool)*1
	}
	if len(m.RepeatedEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedEnum {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSint32) > 0 {
		l = 0
		for _, e := range m.RepeatedSint32 {
			l += sozFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedUint32) > 0 {
		l = 0
		for _, e := range m.RepeatedUint32 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedInt64) > 0 {
		l = 0
		for _, e := range m.RepeatedInt64 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSint64) > 0 {
		l = 0
		for _, e := range m.RepeatedSint64 {
			l += sozFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedUint64) > 0 {
		l = 0
		for _, e := range m.RepeatedUint64 {
			l += sovFields(uint64(e))
		}
		n += 2 + sovFields(uint64(l)) + l
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedSfixed32)*4)) + len(m.RepeatedSfixed32)*4
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFixed32)*4)) + len(m.RepeatedFixed32)*4
	}
	if len(m.RepeatedFloat) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFloat)*4)) + len(m.RepeatedFloat)*4
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedSfixed64)*8)) + len(m.RepeatedSfixed64)*8
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedFixed64)*8)) + len(m.RepeatedFixed64)*8
	}
	if len(m.RepeatedDouble) > 0 {
		n += 2 + sovFields(uint64(len(m.RepeatedDouble)*8)) + len(m.RepeatedDouble)*8
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.Repeated_Message) > 0 {
		for _, e := range m.Repeated_Message {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.Repeated_Message2) > 0 {
		for _, e := range m.Repeated_Message2 {
			l = e.Size()
			n += 2 + l + sovFields(uint64(l))
		}
	}
	if len(m.MapBool) > 0 {
		for k, v := range m.MapBool {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 1
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapEnum) > 0 {
		for k, v := range m.MapEnum {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32) > 0 {
		for k, v := range m.MapInt32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint32) > 0 {
		for k, v := range m.MapSint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sozFields(uint64(k)) + 1 + sozFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint32) > 0 {
		for k, v := range m.MapUint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64) > 0 {
		for k, v := range m.MapInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapSint64) > 0 {
		for k, v := range m.MapSint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sozFields(uint64(k)) + 1 + sozFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapUint64) > 0 {
		for k, v := range m.MapUint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed32) > 0 {
		for k, v := range m.MapSfixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed32) > 0 {
		for k, v := range m.MapFixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapFloat) > 0 {
		for k, v := range m.MapFloat {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapSfixed64) > 0 {
		for k, v := range m.MapSfixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed64) > 0 {
		for k, v := range m.MapFixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapDouble) > 0 {
		for k, v := range m.MapDouble {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapString) > 0 {
		for k, v := range m.MapString {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + len(v) + sovFields(uint64(len(v)))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapBytes) > 0 {
		for k, v := range m.MapBytes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFields(uint64(len(v)))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.Map_Message) > 0 {
		for k, v := range m.Map_Message {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.Map_Message2) > 0 {
		for k, v := range m.Map_Message2 {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + sovFields(uint64(k)) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyInt32) > 0 {
		for k, v := range m.MapKeyInt32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeySint32) > 0 {
		for k, v := range m.MapKeySint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sozFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyUint32) > 0 {
		for k, v := range m.MapKeyUint32 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyInt64) > 0 {
		for k, v := range m.MapKeyInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeySint64) > 0 {
		for k, v := range m.MapKeySint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sozFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyUint64) > 0 {
		for k, v := range m.MapKeyUint64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeySfixed32) > 0 {
		for k, v := range m.MapKeySfixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyFixed32) > 0 {
		for k, v := range m.MapKeyFixed32 {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeySfixed64) > 0 {
		for k, v := range m.MapKeySfixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyFixed64) > 0 {
		for k, v := range m.MapKeyFixed64 {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapKeyString) > 0 {
		for k, v := range m.MapKeyString {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32Int64) > 0 {
		for k, v := range m.MapInt32Int64 {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFields(uint64(k)) + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringMessage) > 0 {
		for k, v := range m.MapStringMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringMessage2) > 0 {
		for k, v := range m.MapStringMessage2 {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFields(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFields(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	if len(m.MapFixed64Enum) > 0 {
		for k, v := range m.MapFixed64Enum {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + sovFields(uint64(v))
			n += mapEntrySize + 2 + sovFields(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FieldTestMessage_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FieldTestMessage_Message2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bool {
		n += 2
	}
	if m.Enum != 0 {
		n += 1 + sovFields(uint64(m.Enum))
	}
	return n
}

func (m *Example) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filed != 0 {
		n += 1 + sovFields(uint64(m.Filed))
	}
	return n
}

func sovFields(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFields(x uint64) (n int) {
	return sovFields(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FieldTestMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldTestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldTestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalBool = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalEnum", wireType)
			}
			m.OptionalEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalEnum |= FieldTestMessage_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			m.OptionalUint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.OptionalSint64 = int64(v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			m.OptionalUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			m.OptionalSfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed32 = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			m.OptionalFixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed32 = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OptionalFloat = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			m.OptionalSfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalSfixed64 = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			m.OptionalFixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFixed64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionalDouble = float64(math.Float64frombits(v))
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional_Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Optional_Message == nil {
				m.Optional_Message = &FieldTestMessage_Message{}
			}
			if err := m.Optional_Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional_Message2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Optional_Message2 == nil {
				m.Optional_Message2 = &FieldTestMessage_Message2{}
			}
			if err := m.Optional_Message2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 201:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RepeatedBool) == 0 {
					m.RepeatedBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 202:
			if wireType == 0 {
				var v FieldTestMessage_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FieldTestMessage_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedEnum = append(m.RepeatedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RepeatedEnum) == 0 {
					m.RepeatedEnum = make([]FieldTestMessage_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FieldTestMessage_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedEnum = append(m.RepeatedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedEnum", wireType)
			}
		case 203:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt32) == 0 {
					m.RepeatedInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 204:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint32) == 0 {
					m.RepeatedSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 205:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint32) == 0 {
					m.RepeatedUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 206:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedInt64) == 0 {
					m.RepeatedInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 207:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedSint64) == 0 {
					m.RepeatedSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 208:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RepeatedUint64) == 0 {
					m.RepeatedUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 209:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedSfixed32) == 0 {
					m.RepeatedSfixed32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 210:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFixed32) == 0 {
					m.RepeatedFixed32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 211:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RepeatedFloat) == 0 {
					m.RepeatedFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 212:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedSfixed64) == 0 {
					m.RepeatedSfixed64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 213:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedFixed64) == 0 {
					m.RepeatedFixed64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 214:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFields
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFields
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RepeatedDouble) == 0 {
					m.RepeatedDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 215:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 216:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 217:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeated_Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repeated_Message = append(m.Repeated_Message, &FieldTestMessage_Message{})
			if err := m.Repeated_Message[len(m.Repeated_Message)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 218:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeated_Message2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repeated_Message2 = append(m.Repeated_Message2, &FieldTestMessage_Message2{})
			if err := m.Repeated_Message2[len(m.Repeated_Message2)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBool == nil {
				m.MapBool = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBool[mapkey] = mapvalue
			iNdEx = postIndex
		case 302:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEnum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapEnum == nil {
				m.MapEnum = make(map[int32]FieldTestMessage_Enum)
			}
			var mapkey int32
			var mapvalue FieldTestMessage_Enum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapEnum[mapkey] = mapvalue
			iNdEx = postIndex
		case 303:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32 == nil {
				m.MapInt32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32[mapkey] = mapvalue
			iNdEx = postIndex
		case 304:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint32 == nil {
				m.MapSint32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 305:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint32 == nil {
				m.MapUint32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 306:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64 == nil {
				m.MapInt64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64[mapkey] = mapvalue
			iNdEx = postIndex
		case 307:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSint64 == nil {
				m.MapSint64 = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 308:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUint64 == nil {
				m.MapUint64 = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 309:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed32 == nil {
				m.MapSfixed32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 310:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed32 == nil {
				m.MapFixed32 = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 311:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFloat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFloat == nil {
				m.MapFloat = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFloat[mapkey] = mapvalue
			iNdEx = postIndex
		case 312:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSfixed64 == nil {
				m.MapSfixed64 = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapSfixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 313:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed64 == nil {
				m.MapFixed64 = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 314:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapDouble", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapDouble == nil {
				m.MapDouble = make(map[int32]float64)
			}
			var mapkey int32
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapDouble[mapkey] = mapvalue
			iNdEx = postIndex
		case 315:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapString == nil {
				m.MapString = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapString[mapkey] = mapvalue
			iNdEx = postIndex
		case 316:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBytes == nil {
				m.MapBytes = make(map[int32][]byte)
			}
			var mapkey int32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFields
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBytes[mapkey] = mapvalue
			iNdEx = postIndex
		case 317:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map_Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map_Message == nil {
				m.Map_Message = make(map[int32]*FieldTestMessage_Message)
			}
			var mapkey int32
			var mapvalue *FieldTestMessage_Message
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map_Message[mapkey] = mapvalue
			iNdEx = postIndex
		case 318:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map_Message2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map_Message2 == nil {
				m.Map_Message2 = make(map[int32]*FieldTestMessage_Message2)
			}
			var mapkey int32
			var mapvalue *FieldTestMessage_Message2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map_Message2[mapkey] = mapvalue
			iNdEx = postIndex
		case 403:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyInt32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyInt32 == nil {
				m.MapKeyInt32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyInt32[mapkey] = mapvalue
			iNdEx = postIndex
		case 404:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeySint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeySint32 == nil {
				m.MapKeySint32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeySint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 405:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyUint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyUint32 == nil {
				m.MapKeyUint32 = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyUint32[mapkey] = mapvalue
			iNdEx = postIndex
		case 406:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyInt64 == nil {
				m.MapKeyInt64 = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyInt64[mapkey] = mapvalue
			iNdEx = postIndex
		case 407:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeySint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeySint64 == nil {
				m.MapKeySint64 = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeySint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 408:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyUint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyUint64 == nil {
				m.MapKeyUint64 = make(map[uint64]int32)
			}
			var mapkey uint64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyUint64[mapkey] = mapvalue
			iNdEx = postIndex
		case 409:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeySfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeySfixed32 == nil {
				m.MapKeySfixed32 = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeySfixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 410:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyFixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyFixed32 == nil {
				m.MapKeyFixed32 = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyFixed32[mapkey] = mapvalue
			iNdEx = postIndex
		case 412:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeySfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeySfixed64 == nil {
				m.MapKeySfixed64 = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeySfixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 413:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyFixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyFixed64 == nil {
				m.MapKeyFixed64 = make(map[uint64]int32)
			}
			var mapkey uint64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyFixed64[mapkey] = mapvalue
			iNdEx = postIndex
		case 415:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKeyString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapKeyString == nil {
				m.MapKeyString = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapKeyString[mapkey] = mapvalue
			iNdEx = postIndex
		case 500:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32Int64 == nil {
				m.MapInt32Int64 = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32Int64[mapkey] = mapvalue
			iNdEx = postIndex
		case 501:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringMessage == nil {
				m.MapStringMessage = make(map[string]*FieldTestMessage_Message)
			}
			var mapkey string
			var mapvalue *FieldTestMessage_Message
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 502:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringMessage2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringMessage2 == nil {
				m.MapStringMessage2 = make(map[string]*FieldTestMessage_Message2)
			}
			var mapkey string
			var mapvalue *FieldTestMessage_Message2
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFields
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFields
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFields
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFields
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldTestMessage_Message2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringMessage2[mapkey] = mapvalue
			iNdEx = postIndex
		case 503:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapFixed64Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFields
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFields
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapFixed64Enum == nil {
				m.MapFixed64Enum = make(map[uint64]FieldTestMessage_Enum)
			}
			var mapkey uint64
			var mapvalue FieldTestMessage_Enum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFields
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFields
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= FieldTestMessage_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFields(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFields
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapFixed64Enum[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldTestMessage_Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldTestMessage_Message2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			m.Enum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enum |= FieldTestMessage_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Example) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFields
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Example: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Example: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filed", wireType)
			}
			m.Filed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFields
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFields(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFields
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFields(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFields
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFields
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFields
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFields
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFields
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFields
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFields        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFields          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFields = fmt.Errorf("proto: unexpected end of group")
)
